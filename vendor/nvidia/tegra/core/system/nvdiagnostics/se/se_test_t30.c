/*
 * Copyright (c) 2012 NVIDIA Corporation.  All rights reserved.
 *
 * NVIDIA Corporation and its licensors retain all intellectual property
 * and proprietary rights in and to this software and related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA Corporation is strictly prohibited.
 */

#include "nvos.h"
#include "nvddk_blockdev.h"
#include "nvddk_se_blockdev.h"
#include "se_test.h"

#define AES_TEXT_MSG_LENGTH_BYTES (64)

typedef struct AesTestVectorData_Rec
{
    NvU8 Key[32];
    NvU8 Iv[NvDdkSeAesConst_IVLengthBytes];
    NvU8 PlainText[AES_TEXT_MSG_LENGTH_BYTES];
    NvU8 CipherText[AES_TEXT_MSG_LENGTH_BYTES];
    NvU32 KeyLen;
    NvU8 NoOfBlocks;
    NvDdkSeAesOperationalMode OpMode;
} AesTestVectorData;

typedef struct CmacTestVectorData_Rec
{
    NvU8 Key[32];
    NvU8 PlainText[AES_TEXT_MSG_LENGTH_BYTES];
    NvU8 Cmac[16];
    NvU32 MsgLen;
} CmacTestVectorData;

CmacTestVectorData CmacTestVector1 =
{
    {
        0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,
        0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c
    },
    {
        0x0
    },
    {
        0xbb,0x1d,0x69,0x29,0xe9,0x59,0x37,0x28,
        0x7f,0xa3,0x7d,0x12,0x9b,0x75,0x67,0x46
    },
    0
};

CmacTestVectorData CmacTestVector2 =
{
    {
        0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,
        0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c
    },
    {
        0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,
        0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
        0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,
        0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
        0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11
    },
    {
        0xdf,0xa6,0x67,0x47,0xde,0x9a,0xe6,0x30,
        0x30,0xca,0x32,0x61,0x14,0x97,0xc8,0x27
    },
    40
};

CmacTestVectorData CmacTestVector3 =
{
    {
        0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,
        0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c
    },
    {
        0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,
        0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
        0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,
        0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
        0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,
        0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef,
        0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17,
        0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10
    },
    {
        0x51,0xf0,0xbe,0xbf,0x7e,0x3b,0x9d,0x92,
        0xfc,0x49,0x74,0x17,0x79,0x36,0x3c,0xfe
    },
    64
};

AesTestVectorData AesCbcVector1 =
{
    /// Case #1: Encrypting 16 bytes (1 block) using AES-CBC with 128-bit key
    {
        /// 128-bit Key
        0x06, 0xa9, 0x21, 0x40, 0x36, 0xb8, 0xa1, 0x5b,
        0x51, 0x2e, 0x03, 0xd5, 0x34, 0x12, 0x00, 0x06
    },
    {
        /// 128-bit IV
        0x3d, 0xaf, 0xba, 0x42, 0x9d, 0x9e, 0xb4, 0x30,
        0xb4, 0x22, 0xda, 0x80, 0x2c, 0x9f, 0xac, 0x41
    },
    /// Plain Text
    "Single block msg",
    {
        /// Cipher text
        0xe3, 0x53, 0x77, 0x9c, 0x10, 0x79, 0xae, 0xb8,
        0x27, 0x08, 0x94, 0x2d, 0xbe, 0x77, 0x18, 0x1a
    },
    /// key length
    16,
    /// Number of AES blocks in the Text
    1,
    NvDdkSeAesOperationalMode_Cbc
};
AesTestVectorData AesCbcVector2 =
{
    /// Case #2: Encrypting 16 bytes (2 blocks) using AES-CBC with 128-bit key
    {
        /// 128-bit Key
        0xc2, 0x86, 0x69, 0x6d, 0x88, 0x7c, 0x9a, 0xa0,
        0x61, 0x1b, 0xbb, 0x3e, 0x20, 0x25, 0xa4, 0x5a
    },
    {
        /// 128-bit IV
        0x56, 0x2e, 0x17, 0x99, 0x6d, 0x09, 0x3d, 0x28,
        0xdd, 0xb3, 0xba, 0x69, 0x5a, 0x2e, 0x6f, 0x58
    },
    {
        /// Plain Text
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
    },
    {
        /// Cipher text
        0xd2, 0x96, 0xcd, 0x94, 0xc2, 0xcc, 0xcf, 0x8a,
        0x3a, 0x86, 0x30, 0x28, 0xb5, 0xe1, 0xdc, 0x0a,
        0x75, 0x86, 0x60, 0x2d, 0x25, 0x3c, 0xff, 0xf9,
        0x1b, 0x82, 0x66, 0xbe, 0xa6, 0xd6, 0x1a, 0xb1
    },
    /// key length
    16,
    /// Number of AES blocks in the Text
    2,
    NvDdkSeAesOperationalMode_Cbc
};
AesTestVectorData AesCbcVector3 =
{
    /// Case #3: Encrypting 16 bytes (3 blocks) using AES-CBC with 128-bit key
    {
        /// 128-bit Key
        0x6c, 0x3e, 0xa0, 0x47, 0x76, 0x30, 0xce, 0x21,
        0xa2, 0xce, 0x33, 0x4a, 0xa7, 0x46, 0xc2, 0xcd
    },
    {
        /// 128-bit IV
        0xc7, 0x82, 0xdc, 0x4c, 0x09, 0x8c, 0x66, 0xcb,
        0xd9, 0xcd, 0x27, 0xd8, 0x25, 0x68, 0x2c, 0x81
    },
    /// Plain Text
    "This is a 48-byte message (exactly 3 AES blocks)",
    {
        /// Cipher text
        0xd0, 0xa0, 0x2b, 0x38, 0x36, 0x45, 0x17, 0x53,
        0xd4, 0x93, 0x66, 0x5d, 0x33, 0xf0, 0xe8, 0x86,
        0x2d, 0xea, 0x54, 0xcd, 0xb2, 0x93, 0xab, 0xc7,
        0x50, 0x69, 0x39, 0x27, 0x67, 0x72, 0xf8, 0xd5,
        0x02, 0x1c, 0x19, 0x21, 0x6b, 0xad, 0x52, 0x5c,
        0x85, 0x79, 0x69, 0x5d, 0x83, 0xba, 0x26, 0x84
    },
    ///key length
    16,
    /// Number of AES blocks in the Text
    3,
    NvDdkSeAesOperationalMode_Cbc
};
AesTestVectorData AesCbcVector4 =
{
    /// Case #4: Encrypting 16 bytes (4 blocks) using AES-CBC with 128-bit key
    {
        /// 128-bit Key
        0x56, 0xe4, 0x7a, 0x38, 0xc5, 0x59, 0x89, 0x74,
        0xbc, 0x46, 0x90, 0x3d, 0xba, 0x29, 0x03, 0x49
    },
    {
        /// 128-bit IV
        0x8c, 0xe8, 0x2e, 0xef, 0xbe, 0xa0, 0xda, 0x3c,
        0x44, 0x69, 0x9e, 0xd7, 0xdb, 0x51, 0xb7, 0xd9
    },
    {
        /// Plain Text
        0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
        0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
        0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
        0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
        0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
        0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf
    },
    {
        /// Cipher text
        0xc3, 0x0e, 0x32, 0xff, 0xed, 0xc0, 0x77, 0x4e,
        0x6a, 0xff, 0x6a, 0xf0, 0x86, 0x9f, 0x71, 0xaa,
        0x0f, 0x3a, 0xf0, 0x7a, 0x9a, 0x31, 0xa9, 0xc6,
        0x84, 0xdb, 0x20, 0x7e, 0xb0, 0xef, 0x8e, 0x4e,
        0x35, 0x90, 0x7a, 0xa6, 0x32, 0xc3, 0xff, 0xdf,
        0x86, 0x8b, 0xb7, 0xb2, 0x9d, 0x3d, 0x46, 0xad,
        0x83, 0xce, 0x9f, 0x9a, 0x10, 0x2e, 0xe9, 0x9d,
        0x49, 0xa5, 0x3e, 0x87, 0xf4, 0xc3, 0xda, 0x55
    },
    /// key length
    16,
    /// Number of AES blocks in the Text
    4,
    NvDdkSeAesOperationalMode_Cbc
};

AesTestVectorData AesCbcVector5 =
{
    {
        0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52, 0xC8, 0x10,
        0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5, 0x62, 0xF8, 0xEA, 0xD2,
        0x52, 0x2C, 0x6B, 0x7B
    },
    {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
    },
    {
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,
        0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A
    },
    {
        0x4F, 0x02, 0x1D, 0xB2, 0x43, 0xBC, 0x63, 0x3D,
        0x71, 0x78, 0x18, 0x3A, 0x9F, 0xA0, 0x71, 0xE8
    },
    24,
    1,
    NvDdkSeAesOperationalMode_Cbc
};

AesTestVectorData AesCbcVector6 =
{
    {
        0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE,
        0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61,
        0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4
    },
    {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
    },
    {
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,
        0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A
    },
    {
        0xF5, 0x8C, 0x4C, 0x04, 0xD6, 0xE5, 0xF1, 0xBA,
        0x77, 0x9E, 0xAB, 0xFB, 0x5F, 0x7B, 0xFB, 0xD6
    },
    32,
    1,
    NvDdkSeAesOperationalMode_Cbc
};

AesTestVectorData AesCbcVector7 =
{
    {
        0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE,
        0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61,
        0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4
    },
    {
        0x39, 0xF2, 0x33, 0x69, 0xA9, 0xD9, 0xBA, 0xCF,
        0xA5, 0x30, 0xE2, 0x63, 0x04, 0x23, 0x14, 0x61
    },
    {
        0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17, 0xAD,
        0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10
    },
    {
        0xB2, 0xEB, 0x05, 0xE2, 0xC3, 0x9B, 0xE9, 0xFC, 0xDA,
        0x6C, 0x19, 0x07, 0x8C, 0x6A, 0x9D, 0x1B
    },
    32,
    1,
    NvDdkSeAesOperationalMode_Cbc
};
AesTestVectorData AesCbcVector8 =
{
    {
        0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52, 0xC8, 0x10,
        0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5, 0x62, 0xF8, 0xEA, 0xD2,
        0x52, 0x2C, 0x6B, 0x7B
    },
    {
        0x57, 0x1B, 0x24, 0x20, 0x12, 0xFB, 0x7A, 0xE0, 0x7F, 0xA9,
        0xBA, 0xAC, 0x3D, 0xF1, 0x02, 0xE0
    },
    {
        0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17, 0xAD, 0x2B,
        0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10
    },
    {
        0x08, 0xB0, 0xE2, 0x79, 0x88, 0x59, 0x88, 0x81, 0xD9, 0x20,
        0xA9, 0xE6, 0x4F, 0x56, 0x15, 0xCD
    },
    24,
    1,
    NvDdkSeAesOperationalMode_Cbc
};

/// ECB vectors taken from National Institute of Standards and
/// Technology (NIST.)
/// http://csrc.nist.gov/groups/ST/toolkit/examples.html
AesTestVectorData AesEcbVector1 =
{
    {
        /// 128-bit Key
        0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
        0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C
    },
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {
        /// Plain Text
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,
        0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A,
        0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C,
        0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51,
        0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11,
        0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF,
        0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17,
        0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10
    },
    {
        /// Cipher text
        0x3A, 0xD7, 0x7B, 0xB4, 0x0D, 0x7A, 0x36, 0x60,
        0xA8, 0x9E, 0xCA, 0xF3, 0x24, 0x66, 0xEF, 0x97,
        0xF5, 0xD3, 0xD5, 0x85, 0x03, 0xB9, 0x69, 0x9D,
        0xE7, 0x85, 0x89, 0x5A, 0x96, 0xFD, 0xBA, 0xAF,
        0x43, 0xB1, 0xCD, 0x7F, 0x59, 0x8E, 0xCE, 0x23,
        0x88, 0x1B, 0x00, 0xE3, 0xED, 0x03, 0x06, 0x88,
        0x7B, 0x0C, 0x78, 0x5E, 0x27, 0xE8, 0xAD, 0x3F,
        0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5D, 0xD4
    },
    /// key length
    16,
    /// Number of AES blocks in the Text
    4,
    NvDdkSeAesOperationalMode_Ecb
};

AesTestVectorData AesEcbVector2 =
{
    {
        0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52, 0xC8, 0x10,
        0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5, 0x62, 0xF8, 0xEA, 0xD2,
        0x52, 0x2C, 0x6B, 0x7B
    },
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D,
        0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A
    },
    {
        0xBD, 0x33, 0x4F, 0x1D, 0x6E, 0x45, 0xF2, 0x5F, 0xF7, 0x12,
        0xA2, 0x14, 0x57, 0x1F, 0xA5, 0xCC
    },
    24,
    1,
    NvDdkSeAesOperationalMode_Ecb
};

AesTestVectorData AesEcbVector3 =
{
    {
        0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE,
        0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61,
        0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4
    },
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D,
        0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A
    },
    {
        0xF3, 0xEE, 0xD1, 0xBD, 0xB5, 0xD2, 0xA0, 0x3C, 0x06, 0x4B,
        0x5A, 0x7E, 0x3D, 0xB1, 0x81, 0xF8
    },
    32,
    1,
    NvDdkSeAesOperationalMode_Ecb
};

static NvError PerformCmacOperation(NvDdkBlockDevHandle SeHandle,
        NvU8* Key, NvU32 KeyLen, NvU8 *pSrcBuf, NvU8 *pDstBuf, NvU32 SrcBufSize,
        NvBool IsFirstChunk, NvBool IsLastChunk)
{
    NvError e = NvSuccess;
    NvDdkSeAesComputeCmacInInfo CmacInInfo;
    NvDdkSeAesComputeCmacOutInfo CmacOutInfo;

    CmacInInfo.Key = Key;
    CmacInInfo.KeyLen = KeyLen;
    CmacInInfo.pBuffer = pSrcBuf;
    CmacInInfo.BufSize = SrcBufSize;
    CmacInInfo.IsFirstChunk = IsFirstChunk;
    CmacInInfo.IsLastChunk  = IsLastChunk;

    if (IsLastChunk)
    {
        CmacOutInfo.pCMAC = pDstBuf;
        CmacOutInfo.CMACLen = 16;
    }
    NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                SeHandle,
                NvDdkSeAesBlockDevIoctlType_CalculateCMAC,
                sizeof(NvDdkSeAesComputeCmacInInfo),
                sizeof(NvDdkSeAesComputeCmacOutInfo),
                (const void *)&CmacInInfo,
                (void *)&CmacOutInfo));
fail:
    return e;
}

NvError SeAesVerifyTest(NvU32 Instance)
{
    NvError e = NvSuccess;
    NvDdkBlockDevHandle SeHandle;
    NvDdkSeAesOperation OpInfo;
    NvDdkSeAesKeyInfo KeyInfo;
    NvDdkSeAesProcessBufferInfo PbInfo;
    NvDdkSeAesSetIvInfo SetIvInfo;
    NvU8 CmacHash[16];
    NvU8 EncryptBuffer[64];
    NvU8 DecryptBuffer[64];
    AesTestVectorData *pAesVec[11];
    CmacTestVectorData *pCmacVec[3];
    NvU32 i;

    pAesVec[0] = &AesCbcVector1;
    pAesVec[1] = &AesCbcVector2;
    pAesVec[2] = &AesCbcVector3;
    pAesVec[3] = &AesCbcVector4;
    pAesVec[4] = &AesCbcVector5;
    pAesVec[5] = &AesCbcVector6;
    pAesVec[6] = &AesCbcVector7;
    pAesVec[7] = &AesCbcVector8;
    pAesVec[8] = &AesEcbVector1;
    pAesVec[9] = &AesEcbVector2;
    pAesVec[10] = &AesEcbVector3;

    for (i = 0; i < 11; i++)
    {
        /// Encryption
        /// Open Se block device
        NV_CHECK_ERROR_CLEANUP(NvDdkSeBlockDevOpen(0, 0, &SeHandle));
        /// select operation
        OpInfo.OpMode = pAesVec[i]->OpMode;
        OpInfo.IsEncrypt = NV_TRUE;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SelectOperation,
                    sizeof(NvDdkSeAesOperation),
                    0,
                    (const void *)&OpInfo,
                    NULL));
        /// Set Iv
        SetIvInfo.pIV = pAesVec[i]->Iv;
        SetIvInfo.VectorSize = 16;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SetIV,
                    sizeof(NvDdkSeAesSetIvInfo),
                    0,
                    (const void *)&SetIvInfo,
                    NULL));
        /// Select key
        KeyInfo.KeyType = NvDdkSeAesKeyType_UserSpecified;
        KeyInfo.KeyLength = pAesVec[i]->KeyLen;
        NvOsMemcpy(KeyInfo.Key, pAesVec[i]->Key, pAesVec[i]->KeyLen);
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SelectKey,
                    sizeof(NvDdkSeAesKeyInfo),
                    0,
                    (const void *)&KeyInfo,
                    NULL));
        /// process buffer
        PbInfo.pSrcBuffer = pAesVec[i]->PlainText;
        PbInfo.pDstBuffer = EncryptBuffer;
        PbInfo.SrcBufSize = pAesVec[i]->NoOfBlocks * 16;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_ProcessBuffer,
                    sizeof(NvDdkSeAesProcessBufferInfo),
                    0,
                    (const void *)&PbInfo,
                    NULL));
        if (!NvOsMemcmp(EncryptBuffer, pAesVec[i]->CipherText, pAesVec[i]->NoOfBlocks * 16))
        {
            NvOsDebugPrintf("\nEncryption :Test vector %d Passed\n", i);
        }
        else
        {
            NvOsDebugPrintf("\nEncryption :Test vector %d failed\n", i);
        }
        /// Decryption
        /// Select Operation
        OpInfo.IsEncrypt = NV_FALSE;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SelectOperation,
                    sizeof(NvDdkSeAesOperation),
                    0,
                    (const void *)&OpInfo,
                    NULL));
        /// Set IV
        SetIvInfo.pIV = pAesVec[i]->Iv;
        SetIvInfo.VectorSize = 16;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_SetIV,
                    sizeof(NvDdkSeAesSetIvInfo),
                    0,
                    (const void *)&SetIvInfo,
                    NULL));
        PbInfo.pSrcBuffer = pAesVec[i]->CipherText;
        PbInfo.pDstBuffer = DecryptBuffer;
        PbInfo.SrcBufSize = pAesVec[i]->NoOfBlocks * 16;
        NV_CHECK_ERROR_CLEANUP(SeHandle->NvDdkBlockDevIoctl(
                    SeHandle,
                    NvDdkSeAesBlockDevIoctlType_ProcessBuffer,
                    sizeof(NvDdkSeAesProcessBufferInfo),
                    0,
                    (const void *)&PbInfo,
                    NULL));
        if (!NvOsMemcmp(DecryptBuffer, pAesVec[i]->PlainText,
                         pAesVec[i]->NoOfBlocks * 16))
        {
            NvOsDebugPrintf("\nDecryption : Test vector %d Passed\n", i);
        }
        else
        {
            NvOsDebugPrintf("\nDecryption : Test vector %d failed\n", i);
        }
        SeHandle->NvDdkBlockDevClose(SeHandle);
    }

    /// Testing  Cmac
    pCmacVec[0] = &CmacTestVector1;
    pCmacVec[1] = &CmacTestVector2;
    pCmacVec[2] = &CmacTestVector3;

    for (i = 0; i < 3; i++)
    {
        /// open Se block device
        NV_CHECK_ERROR_CLEANUP(NvDdkSeBlockDevOpen(0, 0, &SeHandle));

        NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[i]->Key,
                    16, pCmacVec[i]->PlainText,CmacHash, pCmacVec[i]->MsgLen,
                    NV_TRUE, NV_TRUE));
        if (!NvOsMemcmp(CmacHash, pCmacVec[i]->Cmac, 16))
        {
            NvOsDebugPrintf("\nCMAC: Test vector %d Passed\n", i);
        }
        else
        {
            NvOsDebugPrintf("\nCMAC: Test vector %d failed\n", i);
        }
        SeHandle->NvDdkBlockDevClose(SeHandle);
    }
    /// Testing Cmac calling multiple times.
    /// Testing 40B vector.
    NV_CHECK_ERROR_CLEANUP(NvDdkSeBlockDevOpen(0, 0, &SeHandle));

    NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[1]->Key,
                16, pCmacVec[1]->PlainText, NULL, 16,
                NV_TRUE, NV_FALSE));

    NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[1]->Key,
                16, &pCmacVec[1]->PlainText[16], NULL, 16,
                NV_FALSE, NV_FALSE));

    NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[1]->Key,
                16, &pCmacVec[1]->PlainText[32], CmacHash, pCmacVec[1]->MsgLen - 32,
                NV_FALSE, NV_TRUE));

    if (!NvOsMemcmp(CmacHash, pCmacVec[1]->Cmac, 16))
    {
        NvOsDebugPrintf("\nCMAC: Test vector 1 with multiple iterations Passed\n");
    }
    else
    {
        NvOsDebugPrintf("\nCMAC: Test vector 1 with multiple iterations failed\n");
    }
    SeHandle->NvDdkBlockDevClose(SeHandle);

    /// Testing 64B vector.
    NV_CHECK_ERROR_CLEANUP(NvDdkSeBlockDevOpen(0, 0, &SeHandle));

    NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[2]->Key,
                16, pCmacVec[2]->PlainText, NULL, 16,
                NV_TRUE, NV_FALSE));

    NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[2]->Key,
                16, &pCmacVec[2]->PlainText[16], NULL, 16,
                NV_FALSE, NV_FALSE));

    NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[2]->Key,
                16, &pCmacVec[2]->PlainText[32], NULL, 16,
                NV_FALSE, NV_FALSE));

    NV_CHECK_ERROR_CLEANUP(PerformCmacOperation(SeHandle, pCmacVec[2]->Key,
                16, &pCmacVec[2]->PlainText[48], CmacHash, pCmacVec[2]->MsgLen - 48,
                NV_FALSE, NV_TRUE));

    if (!NvOsMemcmp(CmacHash, pCmacVec[2]->Cmac, 16))
    {
        NvOsDebugPrintf("\nCMAC: Test vector 2 with multiple iterations Passed\n");
    }
    else
    {
        NvOsDebugPrintf("\nCMAC: Test vector 2 with multiple iterations failed\n");
    }

    SeHandle->NvDdkBlockDevClose(SeHandle);
fail:
    return e;
}
