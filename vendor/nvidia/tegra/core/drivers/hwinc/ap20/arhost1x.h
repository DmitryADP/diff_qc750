//
// DO NOT EDIT - generated by simspec!
//

#ifndef ___ARHOST1X_H_INC_
#define ___ARHOST1X_H_INC_
// --------------------------------------------------------------------------
//
// Copyright (c) 2004-2012, NVIDIA Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
//
// --------------------------------------------------------------------------
//
// Copyright (c) 2004, NVIDIA Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
//
// Channel IDs
// *************************************
// Not applicable for SC25
// *************************************
// Direct host access latency to external memory
//
// The following formulas can be used to calculate the worst case latencies
// for direct host write/read accesses to external memory:
//
//   Direct write:  (tRP + tRFC + 4*tRCD) + 2 MCclocks + 4 EMCclocks
//   Direct read:   (3*tRAS(min) + 2*tRP + 3*tRCD + tRFC + 8*(tRAS(min) + tRP)) + 6 MCclocks + 7 EMCclocks
//
//   tRP       - precharge period             (18 to 30ns)
//   tRFC      - autorefresh period           (90 to 100ns)
//   tRCD      - activate to read/write       (18 to 40 ns)
//   tRAS(min) - activate to precharge period (45 to 70ns)
//
//   Example 1: Assume tRP=22.5ns, tRFC=75ns, tRCD=22.5ns, tRAS(min)=45ns, and
//   the frequency of EMCclock is 133MHz.  The worst case latencies are:
//
//   Direct write:  217.5ns + 2 MCclocks
//   Direct read:     915ns + 6 MCclocks
//
//   Example 2: Assume tRP=30ns, tRFC=90ns, tRCD=30ns, tRAS(min)=60ns, and
//   the frequency of EMCclock is 133MHz.  The worst case latencies are:
//
//   Direct write:    280ns + 2 MCclocks
//   Direct read:    1210ns + 6 MCclocks
// For the direct write, the delay is equal to the max time required
// for MC to accept the host direct write. It is equal to the max time
// to process one full EMC request (plus refresh), plus the time to pop
// an entry on the mc side of the mc2emc fifo.
//
// Direct write:  (tRP + tRFC + 4 * tRCD) + 3 EMCclocks + 2 MCclocks + 1 EMCclock
//
// For the direct read, the delay is equal to the max time required for
// the read data to come back. We add the time to go through the host1x2mc async
// boundary, plus the time going through the MC pipe, plus the time going through
// the mc2emc async fifo, plus the time to process all the requests that could
// have been pending before the host direct read (thats reqfifo+4 requests because
// there can be 2 requests on the MC side, reqfifo+1 requests in the fifo
// [accounting for the rd_reg option], and one request ongoing).
//
// Direct read:   2 MCclocks [host1x2mc async] + 3 MCclocks [mc pipe] +
//                (1 MCclock + 2 EMCclocks) [mc2emc async] +
//                (3 * tRAS(min) + 2 * tRP + 3 * tRCD + tRFC +
//                 (reqfifo_depth+4) * (tRAS(min) + tRP)) + 5 EMCclocks
//
// There is some redundancy because of double-counting the time it takes for the request
// to travel to EMC. On top of that, the mc2emc fifo will likely not be full when we issue
// non-same page requests (which is what were counting as the worst case).  However, it is
// safest to give a conservative number.
// The 3 types of address ranges in SC15:
//   - Channel mappings (10) starting at NV_HOST1X_MAPPING_CHANNEL_BASE
//   - Internal memory (4MB max)
//   - External memory (32MB max)
#define NV_HOST1X_MAPPING_CHANNEL_BASE  0
// Size and number of channel mappings (16K each, so there's an uncached
// and write-buffered portion)
#define NV_HOST1X_CHANNEL_MAP_SIZE_BITS 14
#define NV_HOST1X_CHANNEL_MAP_SIZE_BYTES        16384
#define NV_HOST1X_DMA_GCNT_VEC  14
// create define for PROTECTED channel ID
#define NV_HOST1X_CHANNELID_PROT        8
// create an INVALID channel define
#define NV_HOST1X_CHANNELID_INVALID     15
#define NV_HOST1X_CHANNEL0_BASE 0
#define NV_HOST1X_CHANNEL1_BASE 16384
#define NV_HOST1X_CHANNEL2_BASE 32768
#define NV_HOST1X_CHANNEL3_BASE 49152
#define NV_HOST1X_CHANNEL4_BASE 65536
#define NV_HOST1X_CHANNEL5_BASE 81920
#define NV_HOST1X_CHANNEL6_BASE 98304
#define NV_HOST1X_CHANNEL7_BASE 114688
#define NV_HOST1X_CHANNEL_PROT_BASE     131072
// Channel mapping memory map
#define HOST1X_CHANNEL_BASE     0
// Command FIFO PIO region
#define HOST1X_CHANNEL_FIFO_PIO_BASE    2048
#define HOST1X_CHANNEL_FIFO_PIO_LIMIT   4095
// Framebuffer buffered memory write region
#define HOST1X_CHANNEL_FBBUF_REGION_BASE        4096
#define HOST1X_CHANNEL_FBBUF_REGION_LIMIT       8191
// Host synchronous register region
#define HOST1X_CHANNEL_SYNC_REG_BASE    12288
#define HOST1X_CHANNEL_SYNC_REG_LIMIT   16383
// Read DMA output regions
#define HOST1X_READ_DMA_OUTPUT_REGION_SIZE      128
#define HOST1X_READ_DMA_OUTPUT_0_BASE   1536
#define HOST1X_READ_DMA_OUTPUT_0_LIMIT  1663
#define HOST1X_READ_DMA_OUTPUT_1_BASE   1664
#define HOST1X_READ_DMA_OUTPUT_1_LIMIT  1791
#define HOST1X_READ_DMA_OUTPUT_2_BASE   1792
#define HOST1X_READ_DMA_OUTPUT_2_LIMIT  1919
#define HOST1X_READ_DMA_OUTPUT_3_BASE   1920
#define HOST1X_READ_DMA_OUTPUT_3_LIMIT  2047
// number of vertex array descriptors for GATHER3D/SETBASE3D
#define HOST1X_MAX_NUM_MODULES  256
#define HOST1X_MODULE_APERTURE_SIZE     262144
#define HOST1X_DIRECT_MODULE_MAX_SIZE   67108864
#define NV_HOST1X_CPU_READ_RETURN_TAG   15

// Packet DIRECT_REG_ADDR
#define DIRECT_REG_ADDR_SIZE 30

#define DIRECT_REG_ADDR_BAR_SHIFT                       _MK_SHIFT_CONST(26)
#define DIRECT_REG_ADDR_BAR_FIELD                       (_MK_MASK_CONST(0x3f) << DIRECT_REG_ADDR_BAR_SHIFT)
#define DIRECT_REG_ADDR_BAR_RANGE                       _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(26)
#define DIRECT_REG_ADDR_BAR_ROW                 0

#define DIRECT_REG_ADDR_MODULE_ID_SHIFT                 _MK_SHIFT_CONST(18)
#define DIRECT_REG_ADDR_MODULE_ID_FIELD                 (_MK_MASK_CONST(0xff) << DIRECT_REG_ADDR_MODULE_ID_SHIFT)
#define DIRECT_REG_ADDR_MODULE_ID_RANGE                 _MK_SHIFT_CONST(25):_MK_SHIFT_CONST(18)
#define DIRECT_REG_ADDR_MODULE_ID_ROW                   0

#define DIRECT_REG_ADDR_REG_OFFSET_SHIFT                        _MK_SHIFT_CONST(2)
#define DIRECT_REG_ADDR_REG_OFFSET_FIELD                        (_MK_MASK_CONST(0xffff) << DIRECT_REG_ADDR_REG_OFFSET_SHIFT)
#define DIRECT_REG_ADDR_REG_OFFSET_RANGE                        _MK_SHIFT_CONST(17):_MK_SHIFT_CONST(2)
#define DIRECT_REG_ADDR_REG_OFFSET_ROW                  0

// The following is the format of opcodes that can be sent through the
// command FIFO.
// HCFCMD
//
// Generic command FIFO packet (contains fields common to all opcodes) and
// is used for initial decode. All command FIFO packets are multiples of
// 32bits.
//

// Packet HCFCMD
#define HCFCMD_SIZE 32

// supported opcodes
#define HCFCMD_OPCODE_SHIFT                     _MK_SHIFT_CONST(28)
#define HCFCMD_OPCODE_FIELD                     (_MK_MASK_CONST(0xf) << HCFCMD_OPCODE_SHIFT)
#define HCFCMD_OPCODE_RANGE                     _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(28)
#define HCFCMD_OPCODE_ROW                       0
#define HCFCMD_OPCODE_SETCL                     _MK_ENUM_CONST(0)
#define HCFCMD_OPCODE_INCR                      _MK_ENUM_CONST(1)
#define HCFCMD_OPCODE_NONINCR                   _MK_ENUM_CONST(2)
#define HCFCMD_OPCODE_MASK                      _MK_ENUM_CONST(3)
#define HCFCMD_OPCODE_IMM                       _MK_ENUM_CONST(4)
#define HCFCMD_OPCODE_RESTART                   _MK_ENUM_CONST(5)
#define HCFCMD_OPCODE_GATHER                    _MK_ENUM_CONST(6)
#define HCFCMD_OPCODE_EXTEND                    _MK_ENUM_CONST(14)    // // ACQUIRE_MLOCK, RELEASE_MLOCK

#define HCFCMD_OPCODE_CHDONE                    _MK_ENUM_CONST(15)

// remaining data based on opcode
#define HCFCMD_DATA_SHIFT                       _MK_SHIFT_CONST(0)
#define HCFCMD_DATA_FIELD                       (_MK_MASK_CONST(0xfffffff) << HCFCMD_DATA_SHIFT)
#define HCFCMD_DATA_RANGE                       _MK_SHIFT_CONST(27):_MK_SHIFT_CONST(0)
#define HCFCMD_DATA_ROW                 0

// HCFSETCL
//
// The SetClass opcode is to specify which class is being to be referenced
// (may cause rerouting of subsequent methods/data). In addition to switching
// classes, the opcode allows some methods to be programmed on the switch
// similar to a HCFMASK opcode.
//

// Packet HCFSETCL
#define HCFSETCL_SIZE 32

// set class
#define HCFSETCL_OPCODE_SHIFT                   _MK_SHIFT_CONST(28)
#define HCFSETCL_OPCODE_FIELD                   (_MK_MASK_CONST(0xf) << HCFSETCL_OPCODE_SHIFT)
#define HCFSETCL_OPCODE_RANGE                   _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(28)
#define HCFSETCL_OPCODE_ROW                     0
#define HCFSETCL_OPCODE_SETCL                   _MK_ENUM_CONST(0)

// starting offset
#define HCFSETCL_OFFSET_SHIFT                   _MK_SHIFT_CONST(16)
#define HCFSETCL_OFFSET_FIELD                   (_MK_MASK_CONST(0xfff) << HCFSETCL_OFFSET_SHIFT)
#define HCFSETCL_OFFSET_RANGE                   _MK_SHIFT_CONST(27):_MK_SHIFT_CONST(16)
#define HCFSETCL_OFFSET_ROW                     0

// class id
#define HCFSETCL_CLASSID_SHIFT                  _MK_SHIFT_CONST(6)
#define HCFSETCL_CLASSID_FIELD                  (_MK_MASK_CONST(0x3ff) << HCFSETCL_CLASSID_SHIFT)
#define HCFSETCL_CLASSID_RANGE                  _MK_SHIFT_CONST(15):_MK_SHIFT_CONST(6)
#define HCFSETCL_CLASSID_ROW                    0

// offset mask
#define HCFSETCL_MASK_SHIFT                     _MK_SHIFT_CONST(0)
#define HCFSETCL_MASK_FIELD                     (_MK_MASK_CONST(0x3f) << HCFSETCL_MASK_SHIFT)
#define HCFSETCL_MASK_RANGE                     _MK_SHIFT_CONST(5):_MK_SHIFT_CONST(0)
#define HCFSETCL_MASK_ROW                       0

// HCFINCR
//
// The Incrementing opcode indicates the offset should be incremented, for
// each data that's part of the packet. The count argument indicates how many
// 32bit values are following. If channel protect is enabled, it means the
// host should prevent a channel switch from occuring at the end of this
// command packet.
//

// Packet HCFINCR
#define HCFINCR_SIZE 32

// incrementing
#define HCFINCR_OPCODE_SHIFT                    _MK_SHIFT_CONST(28)
#define HCFINCR_OPCODE_FIELD                    (_MK_MASK_CONST(0xf) << HCFINCR_OPCODE_SHIFT)
#define HCFINCR_OPCODE_RANGE                    _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(28)
#define HCFINCR_OPCODE_ROW                      0
#define HCFINCR_OPCODE_INCR                     _MK_ENUM_CONST(1)

// starting offset
#define HCFINCR_OFFSET_SHIFT                    _MK_SHIFT_CONST(16)
#define HCFINCR_OFFSET_FIELD                    (_MK_MASK_CONST(0xfff) << HCFINCR_OFFSET_SHIFT)
#define HCFINCR_OFFSET_RANGE                    _MK_SHIFT_CONST(27):_MK_SHIFT_CONST(16)
#define HCFINCR_OFFSET_ROW                      0

// count of data following
#define HCFINCR_COUNT_SHIFT                     _MK_SHIFT_CONST(0)
#define HCFINCR_COUNT_FIELD                     (_MK_MASK_CONST(0xffff) << HCFINCR_COUNT_SHIFT)
#define HCFINCR_COUNT_RANGE                     _MK_SHIFT_CONST(15):_MK_SHIFT_CONST(0)
#define HCFINCR_COUNT_ROW                       0

// HCFNONINCR
//
// The Non-Incrementing opcode indicates the same offset should be sent for
// each data that's part of the packet. The count argument indicates how many
// 32bit values are following. If channel protect is enabled, it means the
// host should prevent a channel switch from occuring at the end of this
// command packet.
//

// Packet HCFNONINCR
#define HCFNONINCR_SIZE 32

// non-incrementing
#define HCFNONINCR_OPCODE_SHIFT                 _MK_SHIFT_CONST(28)
#define HCFNONINCR_OPCODE_FIELD                 (_MK_MASK_CONST(0xf) << HCFNONINCR_OPCODE_SHIFT)
#define HCFNONINCR_OPCODE_RANGE                 _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(28)
#define HCFNONINCR_OPCODE_ROW                   0
#define HCFNONINCR_OPCODE_NONINCR                       _MK_ENUM_CONST(2)

// constant offset
#define HCFNONINCR_OFFSET_SHIFT                 _MK_SHIFT_CONST(16)
#define HCFNONINCR_OFFSET_FIELD                 (_MK_MASK_CONST(0xfff) << HCFNONINCR_OFFSET_SHIFT)
#define HCFNONINCR_OFFSET_RANGE                 _MK_SHIFT_CONST(27):_MK_SHIFT_CONST(16)
#define HCFNONINCR_OFFSET_ROW                   0

// count of data following
#define HCFNONINCR_COUNT_SHIFT                  _MK_SHIFT_CONST(0)
#define HCFNONINCR_COUNT_FIELD                  (_MK_MASK_CONST(0xffff) << HCFNONINCR_COUNT_SHIFT)
#define HCFNONINCR_COUNT_RANGE                  _MK_SHIFT_CONST(15):_MK_SHIFT_CONST(0)
#define HCFNONINCR_COUNT_ROW                    0

// HCFMASK
//
// The Mask opcode, from the starting offset, generates offsets based on where
// the bits are set in the mask. The host expects the amount of data following
// to equal the number of bits set. If channel protect is enabled, it means the
// host should prevent a channel switch from occuring at the end of this
// command packet.
//

// Packet HCFMASK
#define HCFMASK_SIZE 32

// mask
#define HCFMASK_OPCODE_SHIFT                    _MK_SHIFT_CONST(28)
#define HCFMASK_OPCODE_FIELD                    (_MK_MASK_CONST(0xf) << HCFMASK_OPCODE_SHIFT)
#define HCFMASK_OPCODE_RANGE                    _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(28)
#define HCFMASK_OPCODE_ROW                      0
#define HCFMASK_OPCODE_MASK                     _MK_ENUM_CONST(3)

// starting offset
#define HCFMASK_OFFSET_SHIFT                    _MK_SHIFT_CONST(16)
#define HCFMASK_OFFSET_FIELD                    (_MK_MASK_CONST(0xfff) << HCFMASK_OFFSET_SHIFT)
#define HCFMASK_OFFSET_RANGE                    _MK_SHIFT_CONST(27):_MK_SHIFT_CONST(16)
#define HCFMASK_OFFSET_ROW                      0

// bitmask of offsets following
#define HCFMASK_MASK_SHIFT                      _MK_SHIFT_CONST(0)
#define HCFMASK_MASK_FIELD                      (_MK_MASK_CONST(0xffff) << HCFMASK_MASK_SHIFT)
#define HCFMASK_MASK_RANGE                      _MK_SHIFT_CONST(15):_MK_SHIFT_CONST(0)
#define HCFMASK_MASK_ROW                        0

// HCFIMM
//
// The Immediate opcode indicates the offset and data are contained in the
// same 32bit datum. Only the lowest 16 bits of data are sent to the module
// (IMMDATA).  The upper 16 bits are zeroed out.
//

// Packet HCFIMM
#define HCFIMM_SIZE 32

// immediate
#define HCFIMM_OPCODE_SHIFT                     _MK_SHIFT_CONST(28)
#define HCFIMM_OPCODE_FIELD                     (_MK_MASK_CONST(0xf) << HCFIMM_OPCODE_SHIFT)
#define HCFIMM_OPCODE_RANGE                     _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(28)
#define HCFIMM_OPCODE_ROW                       0
#define HCFIMM_OPCODE_IMM                       _MK_ENUM_CONST(4)

// offset
#define HCFIMM_OFFSET_SHIFT                     _MK_SHIFT_CONST(16)
#define HCFIMM_OFFSET_FIELD                     (_MK_MASK_CONST(0xfff) << HCFIMM_OFFSET_SHIFT)
#define HCFIMM_OFFSET_RANGE                     _MK_SHIFT_CONST(27):_MK_SHIFT_CONST(16)
#define HCFIMM_OFFSET_ROW                       0

// immediate data
#define HCFIMM_IMMDATA_SHIFT                    _MK_SHIFT_CONST(0)
#define HCFIMM_IMMDATA_FIELD                    (_MK_MASK_CONST(0xffff) << HCFIMM_IMMDATA_SHIFT)
#define HCFIMM_IMMDATA_RANGE                    _MK_SHIFT_CONST(15):_MK_SHIFT_CONST(0)
#define HCFIMM_IMMDATA_ROW                      0

// HCFRESTART
//
// The Restart opcode is specific to DMA operation and causes the host
// to set DMAGET to (ADDRESS << 4), so the next command fetch will be from
// (DMASTART + DMAGET).
//
// In previous chips bits 27:0 were not decoded and assumed to be 0's
// (allowing only simply wrapping of GET back to the top of the command
// buffer). Starting with sc17, ADDRESS can be 0, for compatibile
// RESTARTs or non-zero acting as a JUMP.
//
// Note that the jump address granularity is 16 bytes, since the bottom 4 bits
// cannot be specified.

// Packet HCFRESTART
#define HCFRESTART_SIZE 32

// restart
#define HCFRESTART_OPCODE_SHIFT                 _MK_SHIFT_CONST(28)
#define HCFRESTART_OPCODE_FIELD                 (_MK_MASK_CONST(0xf) << HCFRESTART_OPCODE_SHIFT)
#define HCFRESTART_OPCODE_RANGE                 _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(28)
#define HCFRESTART_OPCODE_ROW                   0
#define HCFRESTART_OPCODE_RESTART                       _MK_ENUM_CONST(5)

// Address to be assigned to DMAGET when doing a RESTART. The net result is a JUMP instruction.
#define HCFRESTART_ADDRESS_SHIFT                        _MK_SHIFT_CONST(0)
#define HCFRESTART_ADDRESS_FIELD                        (_MK_MASK_CONST(0xfffffff) << HCFRESTART_ADDRESS_SHIFT)
#define HCFRESTART_ADDRESS_RANGE                        _MK_SHIFT_CONST(27):_MK_SHIFT_CONST(0)
#define HCFRESTART_ADDRESS_ROW                  0

// HCFGATHER
//
// The Gather opcode allows contiguous chunks of memory to be fetched and
// placed inline with the command stream, replacing the 2 words of the gather
// command.  It optionally can put an incrementing or non-incrementing opcode
// in the stream ahead of the gathered data.  This allows for the gathered data
// to be a pure data stream and not be required to have host opcodes inside.
//

// Packet HCFGATHER
#define HCFGATHER_SIZE 32

// gather
#define HCFGATHER_OPCODE_SHIFT                  _MK_SHIFT_CONST(28)
#define HCFGATHER_OPCODE_FIELD                  (_MK_MASK_CONST(0xf) << HCFGATHER_OPCODE_SHIFT)
#define HCFGATHER_OPCODE_RANGE                  _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(28)
#define HCFGATHER_OPCODE_ROW                    0
#define HCFGATHER_OPCODE_GATHER                 _MK_ENUM_CONST(6)

// Starting offset (if putting opcode into the stream)
#define HCFGATHER_OFFSET_SHIFT                  _MK_SHIFT_CONST(16)
#define HCFGATHER_OFFSET_FIELD                  (_MK_MASK_CONST(0xfff) << HCFGATHER_OFFSET_SHIFT)
#define HCFGATHER_OFFSET_RANGE                  _MK_SHIFT_CONST(27):_MK_SHIFT_CONST(16)
#define HCFGATHER_OFFSET_ROW                    0

// Insert an opcode (type set by TYPE, initial offset set by OFFSET) immediately before the gathered data stream.
#define HCFGATHER_INSERT_SHIFT                  _MK_SHIFT_CONST(15)
#define HCFGATHER_INSERT_FIELD                  (_MK_MASK_CONST(0x1) << HCFGATHER_INSERT_SHIFT)
#define HCFGATHER_INSERT_RANGE                  _MK_SHIFT_CONST(15):_MK_SHIFT_CONST(15)
#define HCFGATHER_INSERT_ROW                    0
#define HCFGATHER_INSERT_DISABLE                        _MK_ENUM_CONST(0)
#define HCFGATHER_INSERT_ENABLE                 _MK_ENUM_CONST(1)

// Type of opcode to be inserted (incrementing or non-incrementing).  Only valid if INSERT is enabled.
#define HCFGATHER_TYPE_SHIFT                    _MK_SHIFT_CONST(14)
#define HCFGATHER_TYPE_FIELD                    (_MK_MASK_CONST(0x1) << HCFGATHER_TYPE_SHIFT)
#define HCFGATHER_TYPE_RANGE                    _MK_SHIFT_CONST(14):_MK_SHIFT_CONST(14)
#define HCFGATHER_TYPE_ROW                      0
#define HCFGATHER_TYPE_NONINCR                  _MK_ENUM_CONST(0)
#define HCFGATHER_TYPE_INCR                     _MK_ENUM_CONST(1)

// Count of 32-bit words to be gathered from memory
#define HCFGATHER_COUNT_SHIFT                   _MK_SHIFT_CONST(0)
#define HCFGATHER_COUNT_FIELD                   (_MK_MASK_CONST(0x3fff) << HCFGATHER_COUNT_SHIFT)
#define HCFGATHER_COUNT_RANGE                   _MK_SHIFT_CONST(13):_MK_SHIFT_CONST(0)
#define HCFGATHER_COUNT_ROW                     0

// Base address of chunk to be gathered from memory
#define HCFGATHER_ADDRESS_SHIFT                 _MK_SHIFT_CONST(2)
#define HCFGATHER_ADDRESS_FIELD                 (_MK_MASK_CONST(0x3fffffff) << HCFGATHER_ADDRESS_SHIFT)
#define HCFGATHER_ADDRESS_RANGE                 _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(2)
#define HCFGATHER_ADDRESS_ROW                   1

// HCFCHDONE
//
// This opcode indicates to the command processor that the current channel is
// done processing for now and is willing to give up any of its owned modules
// to other channels that need them.
//

// Packet HCFCHDONE
#define HCFCHDONE_SIZE 32

// chdone
#define HCFCHDONE_OPCODE_SHIFT                  _MK_SHIFT_CONST(28)
#define HCFCHDONE_OPCODE_FIELD                  (_MK_MASK_CONST(0xf) << HCFCHDONE_OPCODE_SHIFT)
#define HCFCHDONE_OPCODE_RANGE                  _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(28)
#define HCFCHDONE_OPCODE_ROW                    0
#define HCFCHDONE_OPCODE_CHDONE                 _MK_ENUM_CONST(15)

#define HCFCHDONE_UNUSED_SHIFT                  _MK_SHIFT_CONST(0)
#define HCFCHDONE_UNUSED_FIELD                  (_MK_MASK_CONST(0xfffffff) << HCFCHDONE_UNUSED_SHIFT)
#define HCFCHDONE_UNUSED_RANGE                  _MK_SHIFT_CONST(27):_MK_SHIFT_CONST(0)
#define HCFCHDONE_UNUSED_ROW                    0

// HCFEXTEND
//
// The EXTEND opcode encompasses several opcodes,
// using a secondary opcode field to complete the decode.
//

// Packet HCFEXTEND
#define HCFEXTEND_SIZE 32

#define HCFEXTEND_OPCODE_SHIFT                  _MK_SHIFT_CONST(28)
#define HCFEXTEND_OPCODE_FIELD                  (_MK_MASK_CONST(0xf) << HCFEXTEND_OPCODE_SHIFT)
#define HCFEXTEND_OPCODE_RANGE                  _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(28)
#define HCFEXTEND_OPCODE_ROW                    0
#define HCFEXTEND_OPCODE_EXTEND                 _MK_ENUM_CONST(14)

#define HCFEXTEND_SUBOP_SHIFT                   _MK_SHIFT_CONST(24)
#define HCFEXTEND_SUBOP_FIELD                   (_MK_MASK_CONST(0xf) << HCFEXTEND_SUBOP_SHIFT)
#define HCFEXTEND_SUBOP_RANGE                   _MK_SHIFT_CONST(27):_MK_SHIFT_CONST(24)
#define HCFEXTEND_SUBOP_ROW                     0
#define HCFEXTEND_SUBOP_ACQUIRE_MLOCK                   _MK_ENUM_CONST(0)
#define HCFEXTEND_SUBOP_RELEASE_MLOCK                   _MK_ENUM_CONST(1)

#define HCFEXTEND_VALUE_SHIFT                   _MK_SHIFT_CONST(0)
#define HCFEXTEND_VALUE_FIELD                   (_MK_MASK_CONST(0xffffff) << HCFEXTEND_VALUE_SHIFT)
#define HCFEXTEND_VALUE_RANGE                   _MK_SHIFT_CONST(23):_MK_SHIFT_CONST(0)
#define HCFEXTEND_VALUE_ROW                     0

// MCFACQUIRE_MLOCK
//
// ACQUIRE_MLOCK and RELEASE_MLOCK operations replace the implicit
// locking of modules previously done by SETCL and CHDONE.
// SW is responsible for allocating MLOCKs.
// MLOCK (Module LOCK) bits are visible to all channels.
// ACQUIRE_MLOCK will set MLOCK[indx] to 1, but
// if MLOCK[indx] is already 1, then the channel
// will stall until the mlock arbiter grants the
// lock to that channel.  The mlock arbiter uses
// two round-robin rings, high and low priority.
// A high priority acquire request is always granted
// before a low priority request.  A channel's
// priority can be set using the CH_PRIORITY field.
// If no channel is waiting on MLOCK[indx], then
//

// Packet HCFACQUIRE_MLOCK
#define HCFACQUIRE_MLOCK_SIZE 32

#define HCFACQUIRE_MLOCK_OPCODE_SHIFT                   _MK_SHIFT_CONST(28)
#define HCFACQUIRE_MLOCK_OPCODE_FIELD                   (_MK_MASK_CONST(0xf) << HCFACQUIRE_MLOCK_OPCODE_SHIFT)
#define HCFACQUIRE_MLOCK_OPCODE_RANGE                   _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(28)
#define HCFACQUIRE_MLOCK_OPCODE_ROW                     0
#define HCFACQUIRE_MLOCK_OPCODE_EXTEND                  _MK_ENUM_CONST(14)

#define HCFACQUIRE_MLOCK_SUBOP_SHIFT                    _MK_SHIFT_CONST(24)
#define HCFACQUIRE_MLOCK_SUBOP_FIELD                    (_MK_MASK_CONST(0xf) << HCFACQUIRE_MLOCK_SUBOP_SHIFT)
#define HCFACQUIRE_MLOCK_SUBOP_RANGE                    _MK_SHIFT_CONST(27):_MK_SHIFT_CONST(24)
#define HCFACQUIRE_MLOCK_SUBOP_ROW                      0
#define HCFACQUIRE_MLOCK_SUBOP_ACQUIRE_MLOCK                    _MK_ENUM_CONST(0)

#define HCFACQUIRE_MLOCK_INDX_SHIFT                     _MK_SHIFT_CONST(0)
#define HCFACQUIRE_MLOCK_INDX_FIELD                     (_MK_MASK_CONST(0x1ff) << HCFACQUIRE_MLOCK_INDX_SHIFT)
#define HCFACQUIRE_MLOCK_INDX_RANGE                     _MK_SHIFT_CONST(8):_MK_SHIFT_CONST(0)
#define HCFACQUIRE_MLOCK_INDX_ROW                       0

// MCFRELEASE_MLOCK
//
// RELEASE_MLOCK will clear MLOCK[indx].
// If one or more channels are waiting, then the
// mlock arbiter will pick a channel and
// allow that channel's ACQUIRE_MLOCK to complete.
//

// Packet HCFRELEASE_MLOCK
#define HCFRELEASE_MLOCK_SIZE 32

#define HCFRELEASE_MLOCK_OPCODE_SHIFT                   _MK_SHIFT_CONST(28)
#define HCFRELEASE_MLOCK_OPCODE_FIELD                   (_MK_MASK_CONST(0xf) << HCFRELEASE_MLOCK_OPCODE_SHIFT)
#define HCFRELEASE_MLOCK_OPCODE_RANGE                   _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(28)
#define HCFRELEASE_MLOCK_OPCODE_ROW                     0
#define HCFRELEASE_MLOCK_OPCODE_EXTEND                  _MK_ENUM_CONST(14)

#define HCFRELEASE_MLOCK_SUBOP_SHIFT                    _MK_SHIFT_CONST(24)
#define HCFRELEASE_MLOCK_SUBOP_FIELD                    (_MK_MASK_CONST(0xf) << HCFRELEASE_MLOCK_SUBOP_SHIFT)
#define HCFRELEASE_MLOCK_SUBOP_RANGE                    _MK_SHIFT_CONST(27):_MK_SHIFT_CONST(24)
#define HCFRELEASE_MLOCK_SUBOP_ROW                      0
#define HCFRELEASE_MLOCK_SUBOP_RELEASE_MLOCK                    _MK_ENUM_CONST(1)

#define HCFRELEASE_MLOCK_INDX_SHIFT                     _MK_SHIFT_CONST(0)
#define HCFRELEASE_MLOCK_INDX_FIELD                     (_MK_MASK_CONST(0x1ff) << HCFRELEASE_MLOCK_INDX_SHIFT)
#define HCFRELEASE_MLOCK_INDX_RANGE                     _MK_SHIFT_CONST(8):_MK_SHIFT_CONST(0)
#define HCFRELEASE_MLOCK_INDX_ROW                       0

////////////////////////
// BUSES.SPEC PACKETS //
////////////////////////
// packets describing the host buses (HWRBUS and HRDBUS), with
// sub-packets based on type, describing the DATA portion.
// write-side packet from host -> client module (HWRBUS)

// Packet HOST_CLWR
#define HOST_CLWR_SIZE 55

#define HOST_CLWR_DATA_SHIFT                    _MK_SHIFT_CONST(0)
#define HOST_CLWR_DATA_FIELD                    (_MK_MASK_CONST(0xffffffff) << HOST_CLWR_DATA_SHIFT)
#define HOST_CLWR_DATA_RANGE                    _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(0)
#define HOST_CLWR_DATA_ROW                      0

#define HOST_CLWR_OFFSET_SHIFT                  _MK_SHIFT_CONST(32)
#define HOST_CLWR_OFFSET_FIELD                  (_MK_MASK_CONST(0xffff) << HOST_CLWR_OFFSET_SHIFT)
#define HOST_CLWR_OFFSET_RANGE                  _MK_SHIFT_CONST(47):_MK_SHIFT_CONST(32)
#define HOST_CLWR_OFFSET_ROW                    0

#define HOST_CLWR_BE_SHIFT                      _MK_SHIFT_CONST(48)
#define HOST_CLWR_BE_FIELD                      (_MK_MASK_CONST(0xf) << HOST_CLWR_BE_SHIFT)
#define HOST_CLWR_BE_RANGE                      _MK_SHIFT_CONST(51):_MK_SHIFT_CONST(48)
#define HOST_CLWR_BE_ROW                        0

#define HOST_CLWR_RWN_SHIFT                     _MK_SHIFT_CONST(52)
#define HOST_CLWR_RWN_FIELD                     (_MK_MASK_CONST(0x1) << HOST_CLWR_RWN_SHIFT)
#define HOST_CLWR_RWN_RANGE                     _MK_SHIFT_CONST(52):_MK_SHIFT_CONST(52)
#define HOST_CLWR_RWN_ROW                       0
#define HOST_CLWR_RWN_WRITE                     _MK_ENUM_CONST(0)
#define HOST_CLWR_RWN_READ                      _MK_ENUM_CONST(1)

#define HOST_CLWR_COR_SHIFT                     _MK_SHIFT_CONST(53)
#define HOST_CLWR_COR_FIELD                     (_MK_MASK_CONST(0x1) << HOST_CLWR_COR_SHIFT)
#define HOST_CLWR_COR_RANGE                     _MK_SHIFT_CONST(53):_MK_SHIFT_CONST(53)
#define HOST_CLWR_COR_ROW                       0
#define HOST_CLWR_COR_CLASS                     _MK_ENUM_CONST(0)
#define HOST_CLWR_COR_REGISTER                  _MK_ENUM_CONST(1)

#define HOST_CLWR_CTXSW_SHIFT                   _MK_SHIFT_CONST(54)
#define HOST_CLWR_CTXSW_FIELD                   (_MK_MASK_CONST(0x1) << HOST_CLWR_CTXSW_SHIFT)
#define HOST_CLWR_CTXSW_RANGE                   _MK_SHIFT_CONST(54):_MK_SHIFT_CONST(54)
#define HOST_CLWR_CTXSW_ROW                     0

// when HOST_CLWR_CTXSW bit is set, DATA contains:

// Packet HOST_CLWR_TYPE_CTXSW
#define HOST_CLWR_TYPE_CTXSW_SIZE 20

#define HOST_CLWR_TYPE_CTXSW_CLASS_SHIFT                        _MK_SHIFT_CONST(0)
#define HOST_CLWR_TYPE_CTXSW_CLASS_FIELD                        (_MK_MASK_CONST(0x3ff) << HOST_CLWR_TYPE_CTXSW_CLASS_SHIFT)
#define HOST_CLWR_TYPE_CTXSW_CLASS_RANGE                        _MK_SHIFT_CONST(9):_MK_SHIFT_CONST(0)
#define HOST_CLWR_TYPE_CTXSW_CLASS_ROW                  0

#define HOST_CLWR_TYPE_CTXSW_RESVD_SHIFT                        _MK_SHIFT_CONST(11)
#define HOST_CLWR_TYPE_CTXSW_RESVD_FIELD                        (_MK_MASK_CONST(0x1f) << HOST_CLWR_TYPE_CTXSW_RESVD_SHIFT)
#define HOST_CLWR_TYPE_CTXSW_RESVD_RANGE                        _MK_SHIFT_CONST(15):_MK_SHIFT_CONST(11)
#define HOST_CLWR_TYPE_CTXSW_RESVD_ROW                  0

#define HOST_CLWR_TYPE_CTXSW_CHANNEL_SHIFT                      _MK_SHIFT_CONST(16)
#define HOST_CLWR_TYPE_CTXSW_CHANNEL_FIELD                      (_MK_MASK_CONST(0xf) << HOST_CLWR_TYPE_CTXSW_CHANNEL_SHIFT)
#define HOST_CLWR_TYPE_CTXSW_CHANNEL_RANGE                      _MK_SHIFT_CONST(19):_MK_SHIFT_CONST(16)
#define HOST_CLWR_TYPE_CTXSW_CHANNEL_ROW                        0
#define HOST_CLWR_TYPE_CTXSW_CHANNEL_CH0                        _MK_ENUM_CONST(0)
#define HOST_CLWR_TYPE_CTXSW_CHANNEL_CH1                        _MK_ENUM_CONST(1)
#define HOST_CLWR_TYPE_CTXSW_CHANNEL_CH2                        _MK_ENUM_CONST(2)
#define HOST_CLWR_TYPE_CTXSW_CHANNEL_CH3                        _MK_ENUM_CONST(3)
#define HOST_CLWR_TYPE_CTXSW_CHANNEL_CH4                        _MK_ENUM_CONST(4)
#define HOST_CLWR_TYPE_CTXSW_CHANNEL_CH5                        _MK_ENUM_CONST(5)
#define HOST_CLWR_TYPE_CTXSW_CHANNEL_CH6                        _MK_ENUM_CONST(6)
#define HOST_CLWR_TYPE_CTXSW_CHANNEL_CH7                        _MK_ENUM_CONST(7)
#define HOST_CLWR_TYPE_CTXSW_CHANNEL_CHPROT                     _MK_ENUM_CONST(8)
#define HOST_CLWR_TYPE_CTXSW_CHANNEL_CHINV                      _MK_ENUM_CONST(15)

// when HOST_CLWR_COR is REGISTER and HOST_RWN is READ, DATA contains:

// Packet HOST_CLWR_TYPE_REGRD
#define HOST_CLWR_TYPE_REGRD_SIZE 20

#define HOST_CLWR_TYPE_REGRD_RESVD_SHIFT                        _MK_SHIFT_CONST(0)
#define HOST_CLWR_TYPE_REGRD_RESVD_FIELD                        (_MK_MASK_CONST(0xffff) << HOST_CLWR_TYPE_REGRD_RESVD_SHIFT)
#define HOST_CLWR_TYPE_REGRD_RESVD_RANGE                        _MK_SHIFT_CONST(15):_MK_SHIFT_CONST(0)
#define HOST_CLWR_TYPE_REGRD_RESVD_ROW                  0

#define HOST_CLWR_TYPE_REGRD_CHANNEL_SHIFT                      _MK_SHIFT_CONST(16)
#define HOST_CLWR_TYPE_REGRD_CHANNEL_FIELD                      (_MK_MASK_CONST(0xf) << HOST_CLWR_TYPE_REGRD_CHANNEL_SHIFT)
#define HOST_CLWR_TYPE_REGRD_CHANNEL_RANGE                      _MK_SHIFT_CONST(19):_MK_SHIFT_CONST(16)
#define HOST_CLWR_TYPE_REGRD_CHANNEL_ROW                        0
#define HOST_CLWR_TYPE_REGRD_CHANNEL_CH0                        _MK_ENUM_CONST(0)
#define HOST_CLWR_TYPE_REGRD_CHANNEL_CH1                        _MK_ENUM_CONST(1)
#define HOST_CLWR_TYPE_REGRD_CHANNEL_CH2                        _MK_ENUM_CONST(2)
#define HOST_CLWR_TYPE_REGRD_CHANNEL_CH3                        _MK_ENUM_CONST(3)
#define HOST_CLWR_TYPE_REGRD_CHANNEL_CH4                        _MK_ENUM_CONST(4)
#define HOST_CLWR_TYPE_REGRD_CHANNEL_CH5                        _MK_ENUM_CONST(5)
#define HOST_CLWR_TYPE_REGRD_CHANNEL_CH6                        _MK_ENUM_CONST(6)
#define HOST_CLWR_TYPE_REGRD_CHANNEL_CH7                        _MK_ENUM_CONST(7)
#define HOST_CLWR_TYPE_REGRD_CHANNEL_CHPROT                     _MK_ENUM_CONST(8)
#define HOST_CLWR_TYPE_REGRD_CHANNEL_CHINV                      _MK_ENUM_CONST(15)

// read-side packet from client module -> host (HRDBUS)

// Packet HOST_CLRD
#define HOST_CLRD_SIZE 39

#define HOST_CLRD_DATA_SHIFT                    _MK_SHIFT_CONST(0)
#define HOST_CLRD_DATA_FIELD                    (_MK_MASK_CONST(0xffffffff) << HOST_CLRD_DATA_SHIFT)
#define HOST_CLRD_DATA_RANGE                    _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(0)
#define HOST_CLRD_DATA_ROW                      0

#define HOST_CLRD_CHANNEL_SHIFT                 _MK_SHIFT_CONST(32)
#define HOST_CLRD_CHANNEL_FIELD                 (_MK_MASK_CONST(0xf) << HOST_CLRD_CHANNEL_SHIFT)
#define HOST_CLRD_CHANNEL_RANGE                 _MK_SHIFT_CONST(35):_MK_SHIFT_CONST(32)
#define HOST_CLRD_CHANNEL_ROW                   0
#define HOST_CLRD_CHANNEL_CH0                   _MK_ENUM_CONST(0)
#define HOST_CLRD_CHANNEL_CH1                   _MK_ENUM_CONST(1)
#define HOST_CLRD_CHANNEL_CH2                   _MK_ENUM_CONST(2)
#define HOST_CLRD_CHANNEL_CH3                   _MK_ENUM_CONST(3)
#define HOST_CLRD_CHANNEL_CH4                   _MK_ENUM_CONST(4)
#define HOST_CLRD_CHANNEL_CH5                   _MK_ENUM_CONST(5)
#define HOST_CLRD_CHANNEL_CH6                   _MK_ENUM_CONST(6)
#define HOST_CLRD_CHANNEL_CH7                   _MK_ENUM_CONST(7)
#define HOST_CLRD_CHANNEL_CHPROT                        _MK_ENUM_CONST(8)
#define HOST_CLRD_CHANNEL_CHINV                 _MK_ENUM_CONST(15)

//HACK!  THIS IS THE ONLY PLACE REFCNT/SYNCPT ARE EITHER/OR IMPLEMENTATION
//  MUST REMOVE REFCNT from CLIENTS b4 turning off REFCNT.  To have both
// would require increase buswidth for type (and mod of clients?)
#define HOST_CLRD_TYPE_SHIFT                    _MK_SHIFT_CONST(36)
#define HOST_CLRD_TYPE_FIELD                    (_MK_MASK_CONST(0x3) << HOST_CLRD_TYPE_SHIFT)
#define HOST_CLRD_TYPE_RANGE                    _MK_SHIFT_CONST(37):_MK_SHIFT_CONST(36)
#define HOST_CLRD_TYPE_ROW                      0
#define HOST_CLRD_TYPE_REGISTER                 _MK_ENUM_CONST(0)
#define HOST_CLRD_TYPE_RAISE                    _MK_ENUM_CONST(1)
#define HOST_CLRD_TYPE_SYNCPT                   _MK_ENUM_CONST(2)
#define HOST_CLRD_TYPE_CTXSW_ACK                        _MK_ENUM_CONST(3)

#define HOST_CLRD_INTR_SHIFT                    _MK_SHIFT_CONST(38)
#define HOST_CLRD_INTR_FIELD                    (_MK_MASK_CONST(0x1) << HOST_CLRD_INTR_SHIFT)
#define HOST_CLRD_INTR_RANGE                    _MK_SHIFT_CONST(38):_MK_SHIFT_CONST(38)
#define HOST_CLRD_INTR_ROW                      0
#define HOST_CLRD_INTR_CLEAR                    _MK_ENUM_CONST(0)
#define HOST_CLRD_INTR_SET                      _MK_ENUM_CONST(1)

// when HOST_CLRD_RAISE type is set, DATA contains

// Packet HOST_CLRD_TYPE_RAISE
#define HOST_CLRD_TYPE_RAISE_SIZE 5

#define HOST_CLRD_TYPE_RAISE_VALUE_SHIFT                        _MK_SHIFT_CONST(0)
#define HOST_CLRD_TYPE_RAISE_VALUE_FIELD                        (_MK_MASK_CONST(0x1f) << HOST_CLRD_TYPE_RAISE_VALUE_SHIFT)
#define HOST_CLRD_TYPE_RAISE_VALUE_RANGE                        _MK_SHIFT_CONST(4):_MK_SHIFT_CONST(0)
#define HOST_CLRD_TYPE_RAISE_VALUE_ROW                  0


// Packet HOST_CLRD_TYPE_SYNCPT
#define HOST_CLRD_TYPE_SYNCPT_SIZE 8

#define HOST_CLRD_TYPE_SYNCPT_INDX_SHIFT                        _MK_SHIFT_CONST(0)
#define HOST_CLRD_TYPE_SYNCPT_INDX_FIELD                        (_MK_MASK_CONST(0xff) << HOST_CLRD_TYPE_SYNCPT_INDX_SHIFT)
#define HOST_CLRD_TYPE_SYNCPT_INDX_RANGE                        _MK_SHIFT_CONST(7):_MK_SHIFT_CONST(0)
#define HOST_CLRD_TYPE_SYNCPT_INDX_ROW                  0


// Packet HOST_CLWR_TYPE_SYNCPT
#define HOST_CLWR_TYPE_SYNCPT_SIZE 16

#define HOST_CLWR_TYPE_SYNCPT_COND_SHIFT                        _MK_SHIFT_CONST(8)
#define HOST_CLWR_TYPE_SYNCPT_COND_FIELD                        (_MK_MASK_CONST(0xff) << HOST_CLWR_TYPE_SYNCPT_COND_SHIFT)
#define HOST_CLWR_TYPE_SYNCPT_COND_RANGE                        _MK_SHIFT_CONST(15):_MK_SHIFT_CONST(8)
#define HOST_CLWR_TYPE_SYNCPT_COND_ROW                  0

#define HOST_CLWR_TYPE_SYNCPT_INDX_SHIFT                        _MK_SHIFT_CONST(0)
#define HOST_CLWR_TYPE_SYNCPT_INDX_FIELD                        (_MK_MASK_CONST(0xff) << HOST_CLWR_TYPE_SYNCPT_INDX_SHIFT)
#define HOST_CLWR_TYPE_SYNCPT_INDX_RANGE                        _MK_SHIFT_CONST(7):_MK_SHIFT_CONST(0)
#define HOST_CLWR_TYPE_SYNCPT_INDX_ROW                  0

////////////////////////
// READ DMA PACKETS   //
////////////////////////
// Packet to describe write buffer header (seen by read DMA)

// Packet WRITE_BUFFER_HEADER
#define WRITE_BUFFER_HEADER_SIZE 32

// non-rect mode
#define WRITE_BUFFER_HEADER_BUFFER_SIZE_SHIFT                   _MK_SHIFT_CONST(0)
#define WRITE_BUFFER_HEADER_BUFFER_SIZE_FIELD                   (_MK_MASK_CONST(0xffff) << WRITE_BUFFER_HEADER_BUFFER_SIZE_SHIFT)
#define WRITE_BUFFER_HEADER_BUFFER_SIZE_RANGE                   _MK_SHIFT_CONST(15):_MK_SHIFT_CONST(0)
#define WRITE_BUFFER_HEADER_BUFFER_SIZE_ROW                     0

#define WRITE_BUFFER_HEADER_RAISE_EN_SHIFT                      _MK_SHIFT_CONST(16)
#define WRITE_BUFFER_HEADER_RAISE_EN_FIELD                      (_MK_MASK_CONST(0x1) << WRITE_BUFFER_HEADER_RAISE_EN_SHIFT)
#define WRITE_BUFFER_HEADER_RAISE_EN_RANGE                      _MK_SHIFT_CONST(16):_MK_SHIFT_CONST(16)
#define WRITE_BUFFER_HEADER_RAISE_EN_ROW                        0

#define WRITE_BUFFER_HEADER_RAISE_SHIFT                 _MK_SHIFT_CONST(17)
#define WRITE_BUFFER_HEADER_RAISE_FIELD                 (_MK_MASK_CONST(0x1f) << WRITE_BUFFER_HEADER_RAISE_SHIFT)
#define WRITE_BUFFER_HEADER_RAISE_RANGE                 _MK_SHIFT_CONST(21):_MK_SHIFT_CONST(17)
#define WRITE_BUFFER_HEADER_RAISE_ROW                   0

#define WRITE_BUFFER_HEADER_CHANNEL_SHIFT                       _MK_SHIFT_CONST(22)
#define WRITE_BUFFER_HEADER_CHANNEL_FIELD                       (_MK_MASK_CONST(0xf) << WRITE_BUFFER_HEADER_CHANNEL_SHIFT)
#define WRITE_BUFFER_HEADER_CHANNEL_RANGE                       _MK_SHIFT_CONST(25):_MK_SHIFT_CONST(22)
#define WRITE_BUFFER_HEADER_CHANNEL_ROW                 0

#define WRITE_BUFFER_HEADER_FRAME_START_SHIFT                   _MK_SHIFT_CONST(26)
#define WRITE_BUFFER_HEADER_FRAME_START_FIELD                   (_MK_MASK_CONST(0x1) << WRITE_BUFFER_HEADER_FRAME_START_SHIFT)
#define WRITE_BUFFER_HEADER_FRAME_START_RANGE                   _MK_SHIFT_CONST(26):_MK_SHIFT_CONST(26)
#define WRITE_BUFFER_HEADER_FRAME_START_ROW                     0

#define WRITE_BUFFER_HEADER_FRAME_END_SHIFT                     _MK_SHIFT_CONST(27)
#define WRITE_BUFFER_HEADER_FRAME_END_FIELD                     (_MK_MASK_CONST(0x1) << WRITE_BUFFER_HEADER_FRAME_END_SHIFT)
#define WRITE_BUFFER_HEADER_FRAME_END_RANGE                     _MK_SHIFT_CONST(27):_MK_SHIFT_CONST(27)
#define WRITE_BUFFER_HEADER_FRAME_END_ROW                       0

#define WRITE_BUFFER_HEADER_LARGE_HDR_SHIFT                     _MK_SHIFT_CONST(28)
#define WRITE_BUFFER_HEADER_LARGE_HDR_FIELD                     (_MK_MASK_CONST(0x1) << WRITE_BUFFER_HEADER_LARGE_HDR_SHIFT)
#define WRITE_BUFFER_HEADER_LARGE_HDR_RANGE                     _MK_SHIFT_CONST(28):_MK_SHIFT_CONST(28)
#define WRITE_BUFFER_HEADER_LARGE_HDR_ROW                       0

#define WRITE_BUFFER_HEADER_RESERVED_SHIFT                      _MK_SHIFT_CONST(29)
#define WRITE_BUFFER_HEADER_RESERVED_FIELD                      (_MK_MASK_CONST(0x7) << WRITE_BUFFER_HEADER_RESERVED_SHIFT)
#define WRITE_BUFFER_HEADER_RESERVED_RANGE                      _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(29)
#define WRITE_BUFFER_HEADER_RESERVED_ROW                        0

// Packet to describe DMA request interface (WIREBUS)

// Packet DMA_REQ_IF
#define DMA_REQ_IF_SIZE 3

#define DMA_REQ_IF_BUFFER_RDY_SHIFT                     _MK_SHIFT_CONST(0)
#define DMA_REQ_IF_BUFFER_RDY_FIELD                     (_MK_MASK_CONST(0x1) << DMA_REQ_IF_BUFFER_RDY_SHIFT)
#define DMA_REQ_IF_BUFFER_RDY_RANGE                     _MK_SHIFT_CONST(0):_MK_SHIFT_CONST(0)
#define DMA_REQ_IF_BUFFER_RDY_ROW                       0

#define DMA_REQ_IF_BUFFER_INIT_SHIFT                    _MK_SHIFT_CONST(1)
#define DMA_REQ_IF_BUFFER_INIT_FIELD                    (_MK_MASK_CONST(0x1) << DMA_REQ_IF_BUFFER_INIT_SHIFT)
#define DMA_REQ_IF_BUFFER_INIT_RANGE                    _MK_SHIFT_CONST(1):_MK_SHIFT_CONST(1)
#define DMA_REQ_IF_BUFFER_INIT_ROW                      0

#define DMA_REQ_IF_LAST_BUFFER_SHIFT                    _MK_SHIFT_CONST(2)
#define DMA_REQ_IF_LAST_BUFFER_FIELD                    (_MK_MASK_CONST(0x1) << DMA_REQ_IF_LAST_BUFFER_SHIFT)
#define DMA_REQ_IF_LAST_BUFFER_RANGE                    _MK_SHIFT_CONST(2):_MK_SHIFT_CONST(2)
#define DMA_REQ_IF_LAST_BUFFER_ROW                      0

////////////////////////
// INTERNAL PACKETS   //
////////////////////////
// packets moving between cmod/IF and host1x simulations
//
// Note: the ADDR field below is a full 32bits (though if sent to the
// host is contains an extra address bit (27 bits)
// than what the chip supports, to allow regwrites to the host bfm to
// configure timing parameters.
//

// Packet IF2HOST_PKT
#define IF2HOST_PKT_SIZE 77

// [31:0]
#define IF2HOST_PKT_DATA_SHIFT                  _MK_SHIFT_CONST(0)
#define IF2HOST_PKT_DATA_FIELD                  (_MK_MASK_CONST(0xffffffff) << IF2HOST_PKT_DATA_SHIFT)
#define IF2HOST_PKT_DATA_RANGE                  _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(0)
#define IF2HOST_PKT_DATA_ROW                    0

// [26:0]
#define IF2HOST_PKT_ADDR_SHIFT                  _MK_SHIFT_CONST(32)
#define IF2HOST_PKT_ADDR_FIELD                  (_MK_MASK_CONST(0xffffffff) << IF2HOST_PKT_ADDR_SHIFT)
#define IF2HOST_PKT_ADDR_RANGE                  _MK_SHIFT_CONST(63):_MK_SHIFT_CONST(32)
#define IF2HOST_PKT_ADDR_ROW                    0

#define IF2HOST_PKT_RST_n_SHIFT                 _MK_SHIFT_CONST(64)
#define IF2HOST_PKT_RST_n_FIELD                 (_MK_MASK_CONST(0x1) << IF2HOST_PKT_RST_n_SHIFT)
#define IF2HOST_PKT_RST_n_RANGE                 _MK_SHIFT_CONST(64):_MK_SHIFT_CONST(64)
#define IF2HOST_PKT_RST_n_ROW                   0

#define IF2HOST_PKT_CS_n_SHIFT                  _MK_SHIFT_CONST(65)
#define IF2HOST_PKT_CS_n_FIELD                  (_MK_MASK_CONST(0x1) << IF2HOST_PKT_CS_n_SHIFT)
#define IF2HOST_PKT_CS_n_RANGE                  _MK_SHIFT_CONST(65):_MK_SHIFT_CONST(65)
#define IF2HOST_PKT_CS_n_ROW                    0

#define IF2HOST_PKT_RD_n_SHIFT                  _MK_SHIFT_CONST(66)
#define IF2HOST_PKT_RD_n_FIELD                  (_MK_MASK_CONST(0x1) << IF2HOST_PKT_RD_n_SHIFT)
#define IF2HOST_PKT_RD_n_RANGE                  _MK_SHIFT_CONST(66):_MK_SHIFT_CONST(66)
#define IF2HOST_PKT_RD_n_ROW                    0

#define IF2HOST_PKT_WR_n_SHIFT                  _MK_SHIFT_CONST(67)
#define IF2HOST_PKT_WR_n_FIELD                  (_MK_MASK_CONST(0x1) << IF2HOST_PKT_WR_n_SHIFT)
#define IF2HOST_PKT_WR_n_RANGE                  _MK_SHIFT_CONST(67):_MK_SHIFT_CONST(67)
#define IF2HOST_PKT_WR_n_ROW                    0

#define IF2HOST_PKT_BE_n_SHIFT                  _MK_SHIFT_CONST(68)
#define IF2HOST_PKT_BE_n_FIELD                  (_MK_MASK_CONST(0xf) << IF2HOST_PKT_BE_n_SHIFT)
#define IF2HOST_PKT_BE_n_RANGE                  _MK_SHIFT_CONST(71):_MK_SHIFT_CONST(68)
#define IF2HOST_PKT_BE_n_ROW                    0

#define IF2HOST_PKT_HGP4_RDY_SHIFT                      _MK_SHIFT_CONST(72)
#define IF2HOST_PKT_HGP4_RDY_FIELD                      (_MK_MASK_CONST(0x1) << IF2HOST_PKT_HGP4_RDY_SHIFT)
#define IF2HOST_PKT_HGP4_RDY_RANGE                      _MK_SHIFT_CONST(72):_MK_SHIFT_CONST(72)
#define IF2HOST_PKT_HGP4_RDY_ROW                        0

#define IF2HOST_PKT_CS1_n_SHIFT                 _MK_SHIFT_CONST(68)
#define IF2HOST_PKT_CS1_n_FIELD                 (_MK_MASK_CONST(0x1) << IF2HOST_PKT_CS1_n_SHIFT)
#define IF2HOST_PKT_CS1_n_RANGE                 _MK_SHIFT_CONST(68):_MK_SHIFT_CONST(68)
#define IF2HOST_PKT_CS1_n_ROW                   0

#define IF2HOST_PKT_BURST_SHIFT                 _MK_SHIFT_CONST(69)
#define IF2HOST_PKT_BURST_FIELD                 (_MK_MASK_CONST(0xff) << IF2HOST_PKT_BURST_SHIFT)
#define IF2HOST_PKT_BURST_RANGE                 _MK_SHIFT_CONST(76):_MK_SHIFT_CONST(69)
#define IF2HOST_PKT_BURST_ROW                   0


// Packet HOST2IF_PKT
#define HOST2IF_PKT_SIZE 32

#define HOST2IF_PKT_DATA_SHIFT                  _MK_SHIFT_CONST(0)
#define HOST2IF_PKT_DATA_FIELD                  (_MK_MASK_CONST(0xffffffff) << HOST2IF_PKT_DATA_SHIFT)
#define HOST2IF_PKT_DATA_RANGE                  _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(0)
#define HOST2IF_PKT_DATA_ROW                    0

// HOST_FIFO_WRITE
//
// Format of host command FIFO entries (either written via the host IF
// in PIO or fed from the hosts DMA engine). Currently no side-band bits
// but there may be some added for context switch.
//

// Packet HOST_FIFO_WRITE
#define HOST_FIFO_WRITE_SIZE 32

#define HOST_FIFO_WRITE_DATA_SHIFT                      _MK_SHIFT_CONST(0)
#define HOST_FIFO_WRITE_DATA_FIELD                      (_MK_MASK_CONST(0xffffffff) << HOST_FIFO_WRITE_DATA_SHIFT)
#define HOST_FIFO_WRITE_DATA_RANGE                      _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(0)
#define HOST_FIFO_WRITE_DATA_ROW                        0


// Packet IP_REQ_PKT
#define IP_REQ_PKT_SIZE 36

// [31:0]
#define IP_REQ_PKT_ADDR_SHIFT                   _MK_SHIFT_CONST(0)
#define IP_REQ_PKT_ADDR_FIELD                   (_MK_MASK_CONST(0xffffffff) << IP_REQ_PKT_ADDR_SHIFT)
#define IP_REQ_PKT_ADDR_RANGE                   _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(0)
#define IP_REQ_PKT_ADDR_ROW                     0

#define IP_REQ_PKT_XFER_SIZE_SHIFT                      _MK_SHIFT_CONST(32)
#define IP_REQ_PKT_XFER_SIZE_FIELD                      (_MK_MASK_CONST(0x7) << IP_REQ_PKT_XFER_SIZE_SHIFT)
#define IP_REQ_PKT_XFER_SIZE_RANGE                      _MK_SHIFT_CONST(34):_MK_SHIFT_CONST(32)
#define IP_REQ_PKT_XFER_SIZE_ROW                        0

#define IP_REQ_PKT_WRITE_SHIFT                  _MK_SHIFT_CONST(35)
#define IP_REQ_PKT_WRITE_FIELD                  (_MK_MASK_CONST(0x1) << IP_REQ_PKT_WRITE_SHIFT)
#define IP_REQ_PKT_WRITE_RANGE                  _MK_SHIFT_CONST(35):_MK_SHIFT_CONST(35)
#define IP_REQ_PKT_WRITE_ROW                    0


// Packet IP_WDATA_PKT
#define IP_WDATA_PKT_SIZE 32

#define IP_WDATA_PKT_WDATA_SHIFT                        _MK_SHIFT_CONST(0)
#define IP_WDATA_PKT_WDATA_FIELD                        (_MK_MASK_CONST(0xffffffff) << IP_WDATA_PKT_WDATA_SHIFT)
#define IP_WDATA_PKT_WDATA_RANGE                        _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(0)
#define IP_WDATA_PKT_WDATA_ROW                  0


// Packet IP_RDATA_PKT
#define IP_RDATA_PKT_SIZE 32

#define IP_RDATA_PKT_RDATA_SHIFT                        _MK_SHIFT_CONST(0)
#define IP_RDATA_PKT_RDATA_FIELD                        (_MK_MASK_CONST(0xffffffff) << IP_RDATA_PKT_RDATA_SHIFT)
#define IP_RDATA_PKT_RDATA_RANGE                        _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(0)
#define IP_RDATA_PKT_RDATA_ROW                  0


// Packet PPSB_PKT
#define PPSB_PKT_SIZE 100

#define PPSB_PKT_PADDR_SHIFT                    _MK_SHIFT_CONST(0)
#define PPSB_PKT_PADDR_FIELD                    (_MK_MASK_CONST(0xffffffff) << PPSB_PKT_PADDR_SHIFT)
#define PPSB_PKT_PADDR_RANGE                    _MK_SHIFT_CONST(31):_MK_SHIFT_CONST(0)
#define PPSB_PKT_PADDR_ROW                      0

// [31:0]
#define PPSB_PKT_PWDATA_SHIFT                   _MK_SHIFT_CONST(32)
#define PPSB_PKT_PWDATA_FIELD                   (_MK_MASK_CONST(0xffffffff) << PPSB_PKT_PWDATA_SHIFT)
#define PPSB_PKT_PWDATA_RANGE                   _MK_SHIFT_CONST(63):_MK_SHIFT_CONST(32)
#define PPSB_PKT_PWDATA_ROW                     0

#define PPSB_PKT_PRDATA_SHIFT                   _MK_SHIFT_CONST(64)
#define PPSB_PKT_PRDATA_FIELD                   (_MK_MASK_CONST(0xffffffff) << PPSB_PKT_PRDATA_SHIFT)
#define PPSB_PKT_PRDATA_RANGE                   _MK_SHIFT_CONST(95):_MK_SHIFT_CONST(64)
#define PPSB_PKT_PRDATA_ROW                     0

#define PPSB_PKT_PENABLE_SHIFT                  _MK_SHIFT_CONST(96)
#define PPSB_PKT_PENABLE_FIELD                  (_MK_MASK_CONST(0x1) << PPSB_PKT_PENABLE_SHIFT)
#define PPSB_PKT_PENABLE_RANGE                  _MK_SHIFT_CONST(96):_MK_SHIFT_CONST(96)
#define PPSB_PKT_PENABLE_ROW                    0

#define PPSB_PKT_PSEL_SHIFT                     _MK_SHIFT_CONST(97)
#define PPSB_PKT_PSEL_FIELD                     (_MK_MASK_CONST(0x1) << PPSB_PKT_PSEL_SHIFT)
#define PPSB_PKT_PSEL_RANGE                     _MK_SHIFT_CONST(97):_MK_SHIFT_CONST(97)
#define PPSB_PKT_PSEL_ROW                       0

#define PPSB_PKT_PWRITE_SHIFT                   _MK_SHIFT_CONST(98)
#define PPSB_PKT_PWRITE_FIELD                   (_MK_MASK_CONST(0x1) << PPSB_PKT_PWRITE_SHIFT)
#define PPSB_PKT_PWRITE_RANGE                   _MK_SHIFT_CONST(98):_MK_SHIFT_CONST(98)
#define PPSB_PKT_PWRITE_ROW                     0

#define PPSB_PKT_PREADY_SHIFT                   _MK_SHIFT_CONST(99)
#define PPSB_PKT_PREADY_FIELD                   (_MK_MASK_CONST(0x1) << PPSB_PKT_PREADY_SHIFT)
#define PPSB_PKT_PREADY_RANGE                   _MK_SHIFT_CONST(99):_MK_SHIFT_CONST(99)
#define PPSB_PKT_PREADY_ROW                     0

//#define UPPER_ADDR_SIZE  NV_HOST1X_CPUIF_AW-17;

//
// ADDRESS SPACES
//


//
// ARHOST1X REGISTER BANKS
//


#ifndef _MK_SHIFT_CONST
  #define _MK_SHIFT_CONST(_constant_) _constant_
#endif
#ifndef _MK_MASK_CONST
  #define _MK_MASK_CONST(_constant_) _constant_
#endif
#ifndef _MK_ENUM_CONST
  #define _MK_ENUM_CONST(_constant_) (_constant_ ## UL)
#endif
#ifndef _MK_ADDR_CONST
  #define _MK_ADDR_CONST(_constant_) _constant_
#endif

#endif // ifndef ___ARHOST1X_H_INC_
