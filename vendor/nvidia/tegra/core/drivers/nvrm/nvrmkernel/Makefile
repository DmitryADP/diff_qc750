#
# Copyright (c) 2008 - 2012, NVIDIA CORPORATION.  All rights reserved.
#
# NVIDIA Corporation and its licensors retain all intellectual property
# and proprietary rights in and to this software, related documentation
# and any modifications thereto.  Any use, reproduction, disclosure or
# distribution of this software and related documentation without an express
# license agreement from NVIDIA Corporation is strictly prohibited.
#

TOPDIR := ../../..
include $(TEGRA_TOP)/core-private/make/Makefile.defs

ifeq ($(TARGET_BOARD),simulation)
  LCDEFS += -DPLATFORM_SIMULATION=1
else
  LCDEFS += -DPLATFORM_SIMULATION=0
endif

ifeq ($(NVODM_BOARD_IS_FPGA),1)
  LCDEFS += -DPLATFORM_EMULATION=1
else
  LCDEFS += -DPLATFORM_EMULATION=0
endif

ifeq ($(USE_AOS),1)
  LCDEFS += -DNV_USE_AOS=1
endif

ifeq ($(CPU_CLK_LOW_INITIAL_RATE),1)
  LCDEFS += -DCPU_CLK_LOW_INITIAL_RATE
endif

ifeq ($(NV_TARGET_BOOTLOADER_PINMUX),kernel)
LCDEFS += -DSET_KERNEL_PINMUX
endif

LCDEFS += -DNVRM_TRANSPORT_IN_KERNEL=$(NVRM_TRANSPORT_IN_KERNEL)
LCDEFS += -DCONFIG_PLLP_BASE_AS_408MHZ=$(CONFIG_PLLP_BASE_AS_408MHZ)

ifeq ($(TARGET_OS_SUBTYPE),wm7.0)
  LCDEFS += -DNV_SMP_PM=1
endif

BUILD_STUBS := 0
# AOS and host builds don't use stubs
ifeq ($(TARGET_OS)-$(TARGET_CPU),linux-armv6)
   BUILD_STUBS := 1
   LCINCS += -I$(TEGRA_TOP)/core/mobile_linux/include
   ifeq ($(WIN_INTERFACE),x11)
     # On Linux, we may enable the Xlib path
     SYSTEM_LDLIBS_DLL += -L$(NVLIB_X11_ROOT)/lib -lX11 -lXext
     LCINCS += -I$(NVLIB_X11_ROOT)/include
     LCINCS += $(NVLIB_X11_TDR_INCLUDES)
     LCDEFS += -DHAVE_X11
   endif
endif
ifeq ($(TARGET_OS),qnx)
  BUILD_STUBS := 1
  IDL_FLAGS += -u -O $(TARGET_OS)
  SYSTEM_LDLIBS_DLL += -Bstatic -lcacheS
endif

SHMOO_DATA_INIT := 0
# AOS and host builds don't pass shmoo data as boot argument
# and initialize shmoo data base explicitly
ifeq ($(BUILD_STUBS),0)
  SHMOO_DATA_INIT := 1
endif
ifeq ($(TARGET_OS),qnx)
  SHMOO_DATA_INIT := 1
endif

#
# LIB_IMPL  - the implementation (built but not used in linux-armv6)
# LIB_STUB  - stub functions to call impl (through IOCTL or daemon-socket)
# LIB_SSTUB - statically linked stub library (for wince source release)
# LIB_KSTUB - needed for wince (why???)
#
# TARGETS_* - files to install (.so, .a, .lib, or .lib + .dll)
#
LIB_IMPL :=
LIB_STUB :=
LIB_SSTUB :=
LIB_KSTUB :=

TARGETS_IMPL :=
TARGETS_STUB :=
TARGETS_SSTUB :=
TARGETS_KSTUB :=

ifeq ($(BUILD_STUBS),1)
  ifneq ($(NO_SRC_MODULES),1)
    LIB_IMPL := $(OUTDIR)/libnvrm_impl$(DLL_SUFFIX)
    TARGETS_IMPL := $(addprefix $(OUTDIR)/libnvrm_impl,$(DLL_SUFFIXES))
    LIB_STUB := $(OUTDIR)/libnvrm$(DLL_SUFFIX)
    TARGETS_STUB := $(addprefix $(OUTDIR)/libnvrm,$(DLL_SUFFIXES))
  endif

  # This is a static library version of the stub library.
  # install a .lib for the wince source release build nightmare
  # the source release build will just copy the library, but it can't have
  # the same name as the target library, so name it something silly.
  LIB_SSTUB := $(OUTDIR)/prebuilt_libnvrm$(LIB_SUFFIX)
  TARGETS_SSTUB := $(LIB_SSTUB)
else
  LIB_IMPL := $(OUTDIR)/libnvrm$(DLL_OR_LIB_SUFFIX)
  TARGETS_IMPL := $(addprefix $(OUTDIR)/libnvrm,$(DLL_OR_LIB_SUFFIXES))
endif

LIBS :=
LIBS += $(LIB_IMPL)
LIBS += $(LIB_STUB)
LIBS += $(LIB_SSTUB)
LIBS += $(LIB_KSTUB)

TARGETS :=
TARGETS += $(TARGETS_IMPL)
TARGETS += $(TARGETS_STUB)
TARGETS += $(TARGETS_SSTUB)
TARGETS += $(TARGETS_KSTUB)



LCINCS += $(NVLIB_COMMON_INCLUDES)
LCINCS += -I$(TEGRA_TOP)/core/drivers/nvrm/nvrmkernel/core
LCINCS += -I$(TEGRA_TOP)/core/drivers/nvrm/nvrmkernel/core/common
LCINCS += -I$(TEGRA_TOP)/core/drivers/nvrm/nvrmkernel/io
LCINCS += -I$(TEGRA_TOP)/core/drivers/nvrm/nvrmkernel/io/common
LCINCS += -I$(TEGRA_TOP)/core/drivers/nvrm/graphics/common
LCINCS += -I$(TEGRA_TOP)/core/drivers/nvrm/graphics
LCINCS += -I$(TEGRA_TOP)/core/utils/nvos/aos/nvap
LCINCS += $(NVLIB_HWINC_INCLUDES)
LCINCS += -I$(OUTDIR)

LCDEFS += -DNV_IS_AVP=$(IS_AVP)
LCDEFS += -DNV_IS_DYNAMIC=1
LCDEFS += -DNV_USE_FUSE_CLOCK_ENABLE=0

# For SMMU test use
ifdef NVRM_MEMMGR_USECARVEOUT
LCDEFS += -DNVRM_MEMMGR_USECARVEOUT=$(NVRM_MEMMGR_USECARVEOUT)
endif
ifdef NVRM_T30_REVERSESMMU
LCDEFS += -DNVRM_T30_REVERSESMMU=$(NVRM_T30_REVERSESMMU)
endif
ifdef NVRM_T30_SMMUASID
LCDEFS += -DNVRM_T30_SMMUASID=$(NVRM_T30_SMMUASID)
endif

ARM_FILES :=
C_DISPATCH_FILES :=

# Generated by IDL compiler
GLOBAL_RM_DISPATCH_C_FILE := $(OUTDIR)/NvRm_Dispatch.c

C_FILES :=
C_FILES += core/common/nvrm_pinmux.c
# Implementing custom memory manager stub for QNX.
ifeq ($(TARGET_OS),qnx)
C_FILES += core/common/nvrm_memmgr_qnx.c
C_FILES += core/common/nvrm_memmgr_qnx_common.c
else
C_FILES += core/common/nvrm_heap_simple.c
C_FILES += core/common/nvrm_memmgr.c
C_FILES += core/common/nvrm_heap_carveout.c
C_FILES += core/common/nvrm_heap_secure.c
C_FILES += core/common/nvrm_heap_iram.c
endif
C_FILES += core/common/nvrm_keylist.c
C_FILES += core/common/nvrm_configuration.c
C_FILES += core/common/nvrm_pmu.c
C_FILES += core/common/nvrm_module.c
C_FILES += core/common/nvrm_hwintf.c
C_FILES += core/common/nvrm_chiplib.c
C_FILES += core/common/nvrm_clocks_limits.c
C_FILES += core/common/nvrm_clocks_limits_stub.c
C_FILES += core/common/nvrm_power.c
C_FILES += core/common/nvrm_power_dfs.c
C_FILES += core/common/nvrm_rmctrace.c
C_FILES += core/common/nvrm_relocation_table.c
C_FILES += core/common/nvrm_surface.c
C_FILES += core/common/nvrm_surface_debug.c
C_FILES += io/common/nvrm_i2c.c
C_FILES += io/common/nvrm_gpioi2c.c
C_FILES += io/common/nvrm_owr.c
ifeq ($(TARGET_OS)-$(TARGET_CPU),linux-x86)
  C_FILES += ../graphics/common/nvrm_disasm.c
  C_FILES += ../graphics/common/nvrm_graphics_init.c
  C_FILES += ../graphics/common/nvrm_stream.c
  C_FILES += ../graphics/common/nvsched.c
endif
ifneq ($(TARGET_OS),qnx)
C_FILES += core/common/nvrm_transport.c
ifeq ($(USE_AOS),1)
C_FILES += core/common/nvrm_moduleloader.c
else
C_FILES += core/common/nvrm_moduleloader_linux.c
endif
C_FILES += core/ap15/ap15rm_avp_service.c
C_FILES += core/common/nvrm_avp_cpu_rpc.c
C_FILES += core/ap15/ap15rm_xpc_hw_private.c
C_FILES += core/ap15/ap15rm_xpc.c
endif

# ap15 stuff
C_FILES += io/ap15/ap15rm_dma_hw_private.c
C_FILES += core/ap15/ap15rm_hwmap.c
C_FILES += io/ap15/rm_common_slink_hw_private.c
C_FILES += io/ap15/ap15rm_pwm.c
ifneq ($(TARGET_OS),qnx)
C_FILES += core/ap15/ap15rm_gart.c
endif
C_FILES += core/ap15/ap15rm_clocks.c
C_FILES += core/ap15/ap15rm_clock_config.c
C_FILES += io/ap15/ap15rm_analog.c
C_FILES += core/ap15/nvrm_clocks.c
C_FILES += io/ap15/rm_dma_hw_private.c
C_FILES += core/ap15/ap15rm_power.c
C_FILES += core/ap15/ap15rm_power_dfs.c
C_FILES += core/ap15/ap15rm_power_utils.c
C_FILES += core/ap15/ap15rm_clock_misc.c
C_FILES += core/ap15/ap15rm_memctrl.c
C_FILES += core/ap15/nvrm_diag.c
C_FILES += core/ap15/ap15rm_init.c
C_FILES += core/ap15/ap15rm_init_common.c
C_FILES += core/ap15/ap15rm_interrupt.c
C_FILES += core/ap15/ap15rm_pinmux.c
C_FILES += core/ap15/ap15rm_surface.c
C_FILES += io/ap15/ap15rm_gpio_vi.c
C_FILES += io/ap15/nvrm_dma.c
C_FILES += io/ap15/nvrm_gpio.c
C_FILES += io/ap15/nvrm_gpio_private.c
C_FILES += io/ap15/nvrm_gpio_stub_helper.c
C_FILES += io/ap15/ap15rm_dma_intr.c
C_FILES += io/ap15/rm_spi_hw_private.c
C_FILES += io/ap15/rm_spi_slink.c
ifeq ($(TARGET_OS)-$(TARGET_CPU),linux-x86)
  C_FILES += ../graphics/ap20/ap20rm_channel.c
  C_FILES += ../graphics/ap20/ap20rm_hwcontext.c
  C_FILES += ../graphics/ap20/ap20rm_hostintr.c
  C_FILES += ../graphics/ap20/ap20rm_hwcontext_3d.c
  C_FILES += ../graphics/ap20/ap20rm_hwcontext_mpe.c
  C_FILES += ../graphics/ap20/ap20rm_stream_parse.c
  C_FILES += ../graphics/ap20/ap20sched.c
endif

# ap20 stuff
C_FILES += core/ap20/ap20rm_reloctable.c
C_FILES += core/ap20/ap20rm_clocks.c
C_FILES += core/ap20/ap20rm_clock_config.c
C_FILES += core/ap20/ap20rm_memctrl.c
C_FILES += core/ap20/ap20rm_power_dfs.c
C_FILES += core/ap20/ap20rm_pinmux_tables.c
C_FILES += core/ap20/ap20rm_fuse.c
C_FILES += core/ap20/ap20rm_clocks_info.c
ifneq ($(TARGET_OS),qnx)
C_FILES += core/ap20/ap20rm_gart.c
endif
C_FILES += io/ap20/ap20rm_i2c.c
C_FILES += io/ap20/ap20rm_pcie.c
C_FILES += io/ap20/ap20rm_slink_hw_private.c
C_FILES += io/ap20/ap20rm_owr.c

# t30 stuff
C_FILES += core/t30/t30rm_pinmux.c
C_FILES += core/t30/t30rm_pinmux_tables.c
C_FILES += core/t30/t30rm_reloctable.c
C_FILES += core/t30/t30rm_clocks.c
C_FILES += core/t30/t30rm_clocks_info.c
C_FILES += core/t30/t30rm_memctrl.c
ifneq ($(TARGET_OS),qnx)
C_FILES += core/t30/t30rm_smmu.c
C_FILES += core/t30/t30rm_smmu_clients.c
endif
C_FILES += core/t30/t30rm_fuse.c
C_FILES += io/t30/t30rm_dma_hw_private.c
C_FILES += io/t30/t30rm_slink_hw_private.c
C_FILES += io/t30/t30rm_i2c_slave.c
C_FILES += io/t30/t30rm_owr.c

# hack for non-stub builds
ifneq ($(BUILD_STUBS),1)
  C_FILES += core/common/nvrm_null_stub.c
endif

C_FILES += core/ap15/ap15rm_interrupt_generic.c

IDL_FILES :=
ifeq ($(BUILD_STUBS),1)
  ifeq ($(TARGET_STUB_NVRM),false)
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_analog.idl
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_diag.idl
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_dma.idl
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_gpio.idl
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_i2c.idl
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_owr.idl
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_pwm.idl
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_init.idl
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_interrupt.idl
  endif

  # Linux & QNX use a completely custom memory manager implementation, and
  # the auto-generated stubs shouldn't be used.
  ifneq ($(TARGET_OS)-$(TARGET_CPU),linux-armv6)
    ifneq ($(TARGET_OS),qnx)
      IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_memmgr.idl
    endif
  endif

  ifeq ($(TARGET_STUB_NVRM),false)
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_module.idl
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_pinmux.idl
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_power.idl
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_spi.idl
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_pmu.idl
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_keylist.idl
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_pcie.idl
    IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_memctrl.idl
  endif

  ifeq ($(NVRM_TRANSPORT_IN_KERNEL), 1)
    ifneq ($(TARGET_OS)-$(TARGET_CPU),linux-armv6)
      IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_transport.idl
      IDL_FILES += $(TEGRA_TOP)/core/include/nvrm_xpc.idl
    endif
  endif
endif

ifeq ($(TARGET_OS)-$(TARGET_CPU),linux-armv6)
  C_DISPATCH_FILES += core/common/nvrm_memmgr_null_dispatch.c
  C_DISPATCH_FILES += core/common/nvrm_transport_null_dispatch.c
  C_DISPATCH_FILES += core/common/nvrm_xpc_null_dispatch.c
endif
ifeq ($(TARGET_OS),qnx)
  C_DISPATCH_FILES += core/common/nvrm_memmgr_null_dispatch.c
  C_DISPATCH_FILES += core/common/nvrm_transport_null_dispatch.c
  C_DISPATCH_FILES += core/common/nvrm_xpc_null_dispatch.c
endif

ifeq ($(BUILD_STUBS),1)
  ifeq ($(TARGET_STUB_NVRM),false)
    C_DISPATCH_FILES += $(GLOBAL_RM_DISPATCH_C_FILE)
    C_DISPATCH_FILES += $(patsubst %.idl,$(OUTDIR)/%_dispatch.c,$(notdir $(IDL_FILES)))
  endif
endif

C_FILES += $(C_DISPATCH_FILES)

OBJS_IMPL := $(patsubst %.c,$(OUTDIR)/%$(OBJ_SUFFIX),$(notdir $(C_FILES)))
OBJS_IMPL += $(patsubst %.arm,$(OUTDIR)/%$(OBJ_SUFFIX),$(notdir $(ARM_FILES)))

default: $(LIBS)
ifeq ($(TARGET_OS)-$(TARGET_CPU),linux-armv6)
	echo "UNUSED" > $(LIB_IMPL)
endif
ifneq ($(strip $(TARGETS)),)
	$(NV_INSTALL) -l $(TARGETS) $(INSTALL_TARGET)
endif

DIRT += $(OUTDIR)/NvRm_Dispatch.c

# build stub files
ifeq ($(BUILD_STUBS),1)
  C_STUB_FILES :=
  C_STUB_FILES += core/ap15/ap15rm_surface.c
  C_STUB_FILES += core/ap15/ap15rm_hwmap.c
  C_STUB_FILES += core/common/nvrm_chiplib.c
  C_STUB_FILES += core/common/nvrm_surface.c
  C_STUB_FILES += core/common/nvrm_surface_debug.c
  ifneq ($(TARGET_OS),qnx)
    C_STUB_FILES += core/common/nvrm_moduleloader_linux.c
  endif
  C_KSTUB_FILES := $(C_STUB_FILES)

  # These only go to stub, not kstub
  C_STUB_FILES += core/common/nvrm_stub_helper.c
  C_STUB_FILES += core/common/nvrm_stub_helper_$(TARGET_OS).c
  ifeq ($(TARGET_OS),linux)
    C_STUB_FILES += core/common/nvrm_stub_helper_$(TARGET_OS)_nvmap.c
    C_STUB_FILES += core/common/nvrm_stub_helper_$(TARGET_OS)_ion.c
  endif

  ifeq ($(TARGET_STUB_NVRM),false)
    C_STUB_FILES += io/ap15/nvrm_gpio_stub_helper.c
    C_STUB_FILES += $(patsubst %.idl,$(OUTDIR)/%_stub.c,$(notdir $(IDL_FILES)))
  else
    # NULL stubs
    NULL_STUBS += null_stubs/nvrm_analog_stub.c
    NULL_STUBS += null_stubs/nvrm_diag_stub.c
    NULL_STUBS += null_stubs/nvrm_dma_stub.c
    NULL_STUBS += null_stubs/nvrm_gpio_stub.c
    NULL_STUBS += null_stubs/nvrm_i2c_stub.c
    NULL_STUBS += null_stubs/nvrm_init_stub.c
    NULL_STUBS += null_stubs/nvrm_interrupt_stub.c
    NULL_STUBS += null_stubs/nvrm_keylist_stub.c
    NULL_STUBS += null_stubs/nvrm_memctrl_stub.c
    NULL_STUBS += null_stubs/nvrm_module_stub.c
    NULL_STUBS += null_stubs/nvrm_owr_stub.c
    NULL_STUBS += null_stubs/nvrm_pcie_stub.c
    NULL_STUBS += null_stubs/nvrm_pinmux_stub.c
    NULL_STUBS += null_stubs/nvrm_pmu_stub.c
    NULL_STUBS += null_stubs/nvrm_power_stub.c
    NULL_STUBS += null_stubs/nvrm_pwm_stub.c
    NULL_STUBS += null_stubs/nvrm_spi_stub.c

    C_STUB_FILES += $(NULL_STUBS)
    C_FILES += $(NULL_STUBS);
  endif

  ifeq ($(TARGET_OS),linux)
    C_STUB_FILES += core/common/nvrpc_helper.c
  endif

  ifeq ($(TARGET_OS),qnx)
    C_STUB_FILES += core/common/nvrm_memmgr_qnx_common.c
  endif

  # These only go to kstub, not stub
  C_KSTUB_FILES += core/common/nvrm_null_stub.c

  OBJS_STUB := $(patsubst %.c,$(OUTDIR)/%$(OBJ_SUFFIX),$(notdir $(C_STUB_FILES)))
  OBJS_KSTUB := $(patsubst %.c,$(OUTDIR)/%$(OBJ_SUFFIX),$(notdir $(C_KSTUB_FILES)))

  ifeq ($(TARGET_OS)-$(TARGET_CPU)-$(WIN_INTERFACE),linux-armv6-x11)
    OBJS_STUB += $(NVLIB_X11_TDR)
  endif

  $(LIB_STUB):  $(OBJS_STUB)
  $(LIB_SSTUB): $(OBJS_STUB)
  $(LIB_KSTUB): $(OBJS_KSTUB)

  ifeq ($(TARGET_OS_WINDOWS),1)
    $(LIB_STUB): $(OUTDIR)/libnvrm.def
    $(LIB_KSTUB): $(OUTDIR)/libnvrm_direct.def
    $(LIB_IMPL): $(TEGRA_TOP)/core/include/$(OUTDIR)/libnvrm_impl.def
  endif
  ifeq ($(NV_DEF_USE_DLL),1)
    $(LIB_STUB): $(NVLIB_NVOS)
    ifeq ($(TARGET_OS),qnx)
      $(LIB_STUB): $(NVLIB_IDLHELPER)
    endif
    $(LIB_KSTUB): $(NVLIB_NVOS)
    $(LIB_KSTUB): $(NVLIB_NVRM_IMPL)
  endif
else
  ifeq ($(TARGET_OS_WINDOWS),1)
    $(LIB_IMPL): $(OUTDIR)/libnvrm.def
  endif
endif

$(LIB_IMPL): $(OBJS_IMPL)

$(LIB_IMPL): $(NVLIB_MD5)
$(LIB_STUB): $(NVLIB_MD5)

# the following libraries will be smashed into the RM library on statically-
# linked builds with no exports, so the only way to call these functions is
# through the RM.
$(LIB_IMPL): $(NVLIB_NVINTR)
$(LIB_IMPL): $(NVLIB_NVODM_TMON)
$(LIB_IMPL): $(NVLIB_NVODM_GPIO_EXT)
ifeq ($(SHMOO_DATA_INIT),1)
  $(LIB_IMPL): $(TEGRA_TOP)/core/drivers/nvrm/nvlimits/$(OUTDIR)/libnvrm_limits$(LIB_SUFFIX)
  LCDEFS += -DNV_SHMOO_DATA_INIT=1
endif

ifeq ($(NV_DEF_USE_DLL),1)
  $(LIB_IMPL): $(NVLIB_NVOS)
  $(LIB_IMPL): $(NVLIB_NVREFTRACK)
  # For Linux-x86 builds, the following two libraries (NVODM_QUERY_STATIC,
  # NVODM_SERVICES) must be presented in this order to the linker, since the
  # toolchain we've selected is a special kind of incompetent
  $(LIB_IMPL): $(NVLIB_NVODM_QUERY_STATIC)
  $(LIB_IMPL): $(NVLIB_NVODM_SERVICES)
  $(LIB_IMPL): $(NVLIB_NVODM_PMU)
  $(LIB_IMPL): $(NVLIB_NVRM_GRAPHICS_IMPL)
  ifeq ($(TARGET_OS),qnx)
    $(LIB_IMPL): $(NVLIB_IDLHELPER)
  endif
endif

NVRM_EXPORTS :=
NVRM_EXPORTS += $(TEGRA_TOP)/core/drivers/nvrm/libnvrm.export
NVRM_EXPORTS += $(TEGRA_TOP)/core/drivers/nvrm/libnvrm_stub.export
ifeq ($(NVRM_TRANSPORT_IN_KERNEL), 1)
  NVRM_EXPORTS += $(TEGRA_TOP)/core/drivers/nvrm/libnvrm_transport.export
endif

$(OUTDIR)/libnvrm.def: $(OUTDIR)/dummy.txt $(GET_EXPORTS) $(NVRM_EXPORTS)
	$(PYTHON) $(GET_EXPORTS) \
	        $(MAKE_EXPORT_FILE_FLAGS) \
	        $(BUILD_FLAVOR) \
	        $(TARGET_OS) \
	        $(TARGET_CPU) \
	        $(filter %.export,$^) >$@

$(OUTDIR)/libnvrm_direct.def: $(OUTDIR)/dummy.txt $(GET_EXPORTS) $(NVRM_EXPORTS)
	$(PYTHON) $(GET_EXPORTS) \
	        $(MAKE_EXPORT_FILE_FLAGS) \
	        $(BUILD_FLAVOR) \
	        $(TARGET_OS) \
	        $(TARGET_CPU) \
	        --forward libnvrm_impl \
	        $(filter %.export,$^) >$@

ifeq ($(TARGET_STUB_NVRM),false)
  ifeq ($(BUILD_STUBS),1)
    $(GLOBAL_RM_DISPATCH_C_FILE): $(IDL_COMPILER)
    $(GLOBAL_RM_DISPATCH_C_FILE): $(TEGRA_TOP)/core/include/nvrm.idl
	$(IDL_COMPILER) $(IDL_FLAGS) -g -o $@ $<
  endif
endif

#  Need to release both the stub and the actual source code for RM kernel
RELEASE_PACKAGE_TARGETS := $(TARGETS_STUB) $(TARGETS_IMPL)
RELEASE_PACKAGE_FILES := $(RELEASE_PACKAGE_TARGETS) $(C_FILES) $(C_STUB_FILES)

# Disable the rule to generate stubs to build stubs from the null
# stubs.
ifeq ($(TARGET_STUB_NVRM),true)
  NV_DISABLE_STUB_IDL_RULE := 1
endif
include $(TEGRA_TOP)/core-private/make/Makefile.rules
